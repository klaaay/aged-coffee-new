---
title: 2026-第四周
date: '2026-01-26'
tags: ['WEEKLY-2026']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [2025 年 HTML 新趋势：你需要了解的最新动态](https://frontendmasters.com/blog/bone-up-html-2025/)

本文概述了近年来 HTML 的一些重要更新与特性，涵盖从`<details>`元素的增强到声明式 Shadow DOM 等多个方面，旨在帮助开发者了解现代 HTML 的发展动态。

- 📜 **`<details>`元素现支持通过`name`属性创建“手风琴”式折叠效果**，但需注意其可能存在的可访问性问题，例如会覆盖内部标题的语义。
- 🎨 **可通过 CSS 的`appearance: base-select`声明式地启用可样式化的`<select>`菜单**，未来将允许更自由地设计下拉选择框的样式。
- 🪄 **使用`popover`属性可轻松创建无需 JavaScript 即可打开/关闭的弹出层**，并支持“轻触关闭”等交互模式。
- 🔘 **Safari 已实验性支持`<input type="checkbox" switch>`来创建切换开关**，有望提供更易用的无障碍交互组件。
- 🔍 **新增`<search>`元素用于语义化地包裹搜索区域**，替代以往使用`role="search"`的方式。
- 🔗 **指向`_blank`的链接如今在主流浏览器中已默认具备`noopener`行为**，开发者可考虑简化相关`rel`属性。
- 🌐 **声明式 Shadow DOM 为 Web 组件提供了服务端渲染的可能性**，有助于提升性能与 SEO 效果。
- 🗺️ **Import Maps 允许在浏览器中直接映射模块标识符至 URL**，为无需打包工具的模块化开发提供了基础。
- ⏸️ **`inert`属性可使元素及其子内容完全无法交互且对辅助技术隐藏**，适用于多步骤表单等场景。
- 🔎 **`hidden="until-found"`可在隐藏元素的同时保持其内容可被页面查找功能检索**，并在被找到时触发事件。
- 🌀 **通过 CSS 的`@view-transition { navigation: auto; }`可启用多页面视图过渡动画**，并可在 HTML 中精细控制过渡对象。
- 🎥 **`<video>`元素现重新支持通过`<source media="...">`实现响应式视频源切换**，类似`<picture>`元素的媒体查询功能。

### [AGENTS.md 在我们的代理评估中表现优于技能 - Vercel](https://vercel.com/blog/agents-md-outperforms-skills-in-our-agent-evals)

我们原本预期技能（skills）是教授 AI 编程助手框架特定知识的最佳方案。但在针对 Next.js 16 API 构建评估测试后，我们发现了意想不到的结果：直接嵌入在 AGENTS.md 中的一个压缩的 8KB 文档索引实现了 100% 的通过率，而技能方案即使在明确指示助手使用的情况下，最高也只能达到 79%。如果没有这些指示，技能的表现与完全没有文档时无异。

- 🎯 **问题背景**：AI 编程助手依赖的训练数据会过时。Next.js 16 引入了如 `'use cache'`、`connection()` 和 `forbidden()` 等新 API，这些内容尚未包含在现有模型的训练数据中，导致助手生成错误代码或使用旧模式。
- 🔄 **两种方法**：我们测试了两种方案：1) **技能**：一种按需调用的、打包了提示、工具和文档的开放标准。2) **AGENTS.md**：一个位于项目根目录的 Markdown 文件，为助手提供持久化的上下文信息，无需助手主动加载。
- ❌ **技能的局限性**：在默认情况下，技能在 56% 的评估案例中从未被触发，通过率与无文档基线（53%）相同。即使添加了技能，也未带来任何提升。
- 📝 **指令的脆弱性**：在 AGENTS.md 中添加明确指令（如“先探索项目结构，然后调用技能”）能将技能触发率提升至 95% 以上，通过率提高到 79%。但指令的细微措辞变化会导致助手行为结果差异巨大，方案显得脆弱。
- 🧪 **可靠的评估**：我们强化了评估测试套件，专注于测试那些不在模型训练数据中的 Next.js 16 API，确保了结果的可信度。
- 💡 **关键洞察与方案**：我们尝试将文档索引直接嵌入 AGENTS.md，并添加关键指令：“对于任何 Next.js 任务，优先采用检索引导的推理，而非预训练引导的推理”。这移除了助手“是否需要查找”的决策点。
- 🏆 **出乎意料的结果**：AGENTS.md 文档索引方案在强化评估中实现了 100% 的通过率，在构建、代码检查和测试各项细分指标上均获满分，显著超越了技能方案（即使有明确指令）。
- 🤔 **原因分析**：被动上下文（AGENTS.md）优于主动检索（技能）的原因可能在于：1) 无决策点；2) 信息持续可用；3) 避免了“先读文档还是先探索项目”的排序问题。
- 📦 **处理上下文膨胀**：通过压缩，我们将初始约 40KB 的文档注入内容减少到 8KB（压缩 80%），同时保持了 100% 的通过率。压缩格式使用管道分隔的结构，将文档索引打包到最小空间，助手在需要时可读取`.next-docs/`目录中的具体文件。
- 🛠️ **如何尝试**：可以通过命令 `npx @next/codemod@canary agents-md` 为你的 Next.js 项目一键设置。该命令会检测 Next.js 版本，下载匹配的文档到`.next-docs/`，并将压缩索引注入到你的 AGENTS.md 中。
- 📚 **对框架作者的启示**：技能并非无用，它更适用于用户明确触发的、垂直的、特定动作的工作流（如升级版本、迁移路由）。而对于通用的框架知识，目前被动的上下文方案表现更优。建议：不要等待技能改进；积极压缩内容；使用针对未训练 API 的评估进行测试；设计便于检索的文档结构。最终目标是推动助手从“预训练引导的推理”转向“检索引导的推理”，而 AGENTS.md 是目前实现这一目标最可靠的方式。

### [我们修复了一个长达 6 年的 JavaScript 内存泄漏问题 | DebugBear](https://www.debugbear.com/blog/javascript-memory-leak)

我们修复了一个持续 6 年的 JavaScript 内存泄漏问题，该问题导致云函数因内存不足而偶尔崩溃，但未对业务造成显著影响。

- 🐛 **内存泄漏根源**：使用 lodash 的 memoize 函数缓存数据时，未清理旧缓存导致内存持续累积
- 🔧 **修复方法**：通过手动清除 memoize 缓存或改用 LRU 缓存策略，定期释放内存
- ⏳ **长期忽视原因**：本地测试难以复现（需处理大量不同 URL 才会显现），且生产环境无法获取堆快照
- 🛡️ **业务影响轻微**：系统具备重试机制，崩溃后能自动恢复，仅轻微增加 CPU 时间和重试成本
- 💡 **意外收获**：修复同时优化了前端代码内存使用，虽然后端处理量远大于前端场景
- 📊 **历史背景**：2019 年曾通过增加内存临时缓解，近期因优化性能代码时重新发现根本原因

### [什么是 HTTP 头部？](https://httpcolon.dev/)

本文概述了 HTTP 响应头中`Cache-Control`指令的各类用途与含义，用于控制缓存行为以平衡性能、新鲜度和隐私。

- 🕐 **max-age=N**：表示响应自服务器生成起保持新鲜的时间为 N 秒，缓存时间需减去响应在途中已消耗的时间（通过`Age`头判断）。
- 🌐 **public**：允许任何缓存（包括共享代理缓存）存储该响应，可提高缓存命中率但可能涉及隐私风险。
- 🔒 **private**：响应仅允许存储在非共享缓存（如浏览器缓存）中，适用于包含敏感个人信息的数据。
- 🔄 **no-cache**：在使用缓存响应前必须向源服务器重新验证其新鲜度，会忽略`max-age`等设置。
- 🚫 **no-store**：禁止任何缓存存储响应内容，适用于高度敏感信息（如金融数据）。
- ⚙️ **s-maxage=N**：仅作用于共享缓存（如代理），可覆盖`max-age`，对私有缓存无效。
- ✋ **no-transform**：禁止中间缓存（如代理）修改响应内容，保护数据的完整性与安全性。
- ⚠️ **must-revalidate**：缓存必须在使用前重新验证过期响应，禁止直接提供过期内容。
- 🔁 **proxy-revalidate**：类似`must-revalidate`，但仅作用于共享缓存，对私有缓存无效。
- 📚 **must-understand**：非标准指令，表示缓存仅在其理解基于状态码的缓存要求时才应存储响应。
- 🧱 **immutable**：表示响应内容不可变，缓存期间禁止任何修改，适合长期不变的静态资源。
- ⏳ **stale-while-revalidate**：允许在后台重新验证时继续提供过期响应，以提升用户体验与性能。
- 🆘 **stale-if-error**：当无法连接源服务器时，允许在指定时间内提供过期响应作为容错机制。

### [我的 2026 年 React 生态系统栈 | Felipe Gustavo 的博客](https://www.felgus.dev/blog/react-stack-2026)

2026 年 React 生态圈趋于稳定，核心工具变化不大，但路由和框架选择出现新动向，同时 React Server Components 面临采用挑战。

- 🧠 **状态管理**：Zustand 已成为默认选择，使用广泛且稳定。
- 🔄 **服务器状态**：Tanstack Query（原 React Query）仍是处理服务器状态的首选，体验流畅。
- 🎨 **样式方案**：Tailwind CSS 主导前端领域，与 LLM 配合良好，Shadcn/ui 作为易定制的 UI 库成为行业标准。
- ⚡ **测试与构建**：Vitest 在新项目中取代 Jest，性能优异；Vite 继续主导打包工具市场；React Testing Library 保持组件测试最佳工具地位。
- 📝 **表单处理**：React-hook-form 结合 Zod 等验证工具，仍是表单状态管理最优解。
- 🌐 **React Server Components**：采用进展缓慢，沟通偏差和安全漏洞（已快速修复）影响声誉，本质是替代 REST API 而非 SSR。
- 🏗️ **框架演变**：Next.js 仍是主流，但 Vercel 争议和 RSC 策略引发不满；Tanstack Start 凭借良好口碑可能崛起。
- 🧭 **路由革新**：Tanstack Router 整合缓存概念，提供更优 SPA 体验，逐渐替代混乱的 React Router。
- 🚀 **未来趋势**：Base UI、HeroUI 等组件库和 React Bits 动画库兴起；React v19 的 View Transition 等新特性将推动动画和并发功能发展。

## 工具

### [Facehash - 适用于 React 的优雅极简头像](https://www.facehash.dev/)

Facehash 是一个轻量级 React 组件，能够根据任意字符串生成独特的头像。它无需依赖外部服务，完全离线运行，确保相同输入始终产生相同头像，并支持通过 Next.js 路由生成 PNG 图片。该组件适用于用户资料、聊天应用、评论区和 AI 代理等多种场景。

- 🎨 **生成独特头像**：根据字符串（如邮箱、用户名）生成友好、一致的头像
- 📦 **零依赖轻量**：无外部依赖，适用于 Next.js、Vite、Remix 等框架
- 🔄 **完全确定性**：相同输入必得相同头像，无需 API 调用或存储
- 🖼️ **支持图片生成**：通过 Next.js 路由处理程序生成可缓存的 PNG 图片
- ⚙️ **高度可定制**：支持调整尺寸、颜色、3D 强度、变体等属性
- ♿ **默认无障碍**：内置可访问性支持，提供完整的 TypeScript 类型
- 🛠️ **灵活使用方式**：可直接使用 React 组件或通过图片 URL 调用
- 🧩 **包含头像包装器**：提供 Avatar 组件支持图片加载失败时的回退显示
- 🌐 **广泛适用场景**：适用于用户资料、聊天应用、评论系统、游戏及 AI 代理等

### [GitHub - CameronFoxly/Ascii-Motion：一款用于创建和动画化ASCII艺术的现代Web应用](https://github.com/cameronfoxly/Ascii-Motion)

Ascii-Motion 是一个用于创建和动画化 ASCII/ANSI 艺术的现代 Web 应用程序，采用双许可证和单体仓库结构，提供丰富的编辑、动画和导出功能。

- 🎨 **功能特性**：提供基于网格的 ASCII 艺术编辑器、动画时间轴、自定义调色板、图像/视频转 ASCII、多种导出格式以及社区画廊分享。
- 🚀 **快速开始**：项目需要 Node.js 18+ 环境，通过 `git clone` 和 `npm install` 安装，使用 `npm run dev` 进行开发。
- 🌐 **部署结构**：包含三个可独立部署的应用（主应用、营销站点、文档站点），分别部署到不同域名，支持自动化版本管理。
- 🏗️ **技术栈**：基于 React 18、TypeScript、Vite、Tailwind CSS、Shadcn/ui、Zustand 和 Lucide React 构建。
- 📦 **项目结构**：采用单体仓库设计，核心功能（MIT 许可证）与高级功能（专有许可证）分离，便于贡献者参与开源部分开发。
- 📋 **开发状态**：项目由个人维护，已完成基础编辑器、动画系统、导出/导入系统和高级工具等阶段，未来计划包括数据库集成和社区功能。
- 🤝 **贡献指南**：欢迎对核心开源包贡献新工具、动画功能、UI 改进等，需遵循项目代码规范并通过 PR 流程提交。

### [travels](https://github.com/mutativejs/travels)

Travels 是一个与框架无关的高性能撤销/重做库，它通过仅存储状态变化（JSON 补丁）而非完整快照，实现了卓越的内存效率和速度。

- 🚀 **性能卓越**：采用差异存储（JSON Patches），相比传统快照方式内存占用极低，处理速度提升 10 倍。
- 🔧 **框架无关**：可无缝集成于 React、Vue、Zustand、MobX、Pinia 或原生 JavaScript 项目。
- 💾 **内存高效**：仅存储状态间的差异补丁，而非完整对象副本，大幅节省内存。
- ⚙️ **灵活模式**：支持默认的**不可变模式**和专为响应式状态设计的**可变模式**（`mutable: true`）。
- 📅 **存档控制**：提供自动存档（默认）与手动存档模式，方便批量操作归并为单个历史步骤。
- 🧩 **核心概念清晰**：基于状态、草稿、补丁、位置和存档等概念，提供直观的 API。
- 📚 **功能全面**：包含创建实例、状态更新、历史导航（撤销/重做/跳转）、订阅变更、持久化存储等完整功能。
- ⚠️ **状态要求**：状态必须为 JSON 可序列化数据（对象、数组、基本类型），不支持 Date、类实例等复杂类型。
- 🔌 **集成示例**：文档提供了与 React、Vue、Zustand 等流行框架/状态库的集成代码示例。
- 💡 **高级扩展**：支持通过包装方法添加验证、权限、日志记录等自定义逻辑。

### [react-timeline-editor](https://github.com/xzdarcy/react-timeline-editor)

这是一个名为 `react-timeline-editor` 的 React 开源组件库，用于快速构建时间线动画编辑器。

- 🎬 **核心功能**：一个用于快速构建时间线动画编辑器的 React 组件。
- 📦 **获取方式**：可通过 npm 安装 `@xzdarcy/react-timeline-editor` 包来使用。
- ⚙️ **基本使用**：通过导入 `Timeline` 等组件，并提供编辑器数据 (`editorData`) 和效果定义 (`effects`) 即可渲染。
- 📚 **文档完善**：提供在线文档，展示了基础与高级功能的使用演示。
- 🏷️ **项目状态**：已发布稳定版 v1.0.0，项目历史已有 4 年。
- 🌐 **相关数据**：在 GitHub 上获得 642 个星标，154 个复刻，使用以 TypeScript 为主的语言开发。
- 📄 **许可协议**：采用 MIT 开源许可证发布。

### [GitHub - mutativejs/travels：基于Mutative JSON Patch 的快速、框架无关的撤销/重做核心库](https://github.com/mutativejs/travels)

Travels 是一个基于 Mutative JSON Patch 的快速、框架无关的撤销/重做核心库，通过仅存储状态差异而非完整快照来实现高效内存使用和快速更新。

- 🚀 **高性能与内存高效** – 仅存储状态差异（JSON Patches），相比传统快照方式内存占用大幅降低，更新速度提升 10 倍。
- 🔧 **框架无关** – 可与 React、Vue、Zustand、MobX、Pinia 或原生 JavaScript 配合使用。
- 📦 **灵活的更新方式** – 支持直接赋值、函数返回新状态或通过草案（draft）进行可变式更新。
- ⏪ **完整的撤销/重做功能** – 提供 back、forward、go、reset 等方法，支持历史记录导航与状态重置。
- 🧩 **两种存档模式** – 自动存档（每次 setState 即记录）和手动存档（可批量操作后统一存档），适应不同场景需求。
- 🔄 **可变模式支持** – 适用于需要保持对象引用稳定的响应式状态库（如 MobX、Vue/Pinia），避免破坏观察者机制。
- 📝 **状态要求严格** – 仅支持 JSON 可序列化的数据类型（对象、数组、基本类型等），复杂类型需预先转换。
- 🛠️ **丰富的 API 与配置** – 提供订阅、历史记录获取、持久化存储、TypeScript 支持等，并可扩展自定义逻辑（验证、日志、权限等）。
- 📚 **完善的集成示例** – 提供 React、Vue、Zustand 等框架的集成代码，便于快速上手。

### [pdf2video](https://github.com/DangJin/pdf2video)

pdf2video 是一个基于 Remotion 框架的工具，可将 PDF 文档转换为具有平滑动画效果的动态视频演示。

- 🎬 **核心功能**：将 PDF 文档转换为带有多种动画场景（如堆叠、聚焦、切换、扇形展开）的演示视频。
- 🛠️ **智能特性**：包含智能动画（如呼吸、反弹效果）、标题系统、底部信息栏、自动时长计算及背景音乐。
- 🚀 **快速上手**：通过 npm 安装，将 PDF 和背景音乐放入 `public/` 文件夹，即可进行开发预览和视频渲染。
- ⚙️ **灵活配置**：支持基础配置（如高亮页面、自定义标题）和自定义脚本，以完全控制演示流程。
- 🤖 **Claude 集成**：内置 Claude Code 技能，可自动分析 PDF 内容并生成视频配置。
- 📁 **项目结构清晰**：包含配置、资源、输出和源代码目录，便于定制和扩展。
- 🧰 **技术栈**：基于 Remotion、react-pdf、pdfjs-dist 和 Zod 构建，输出 1080p 30fps 视频。

### [agentation](https://github.com/benjitaylor/agentation)

Agentation 是一个与 AI 代理无关的可视化反馈工具，允许用户在网页上点击元素、添加注释，并生成结构化输出，以帮助 AI 编程代理准确定位代码位置。

- 🛠️ **工具简介** – Agentation 是一个可视化反馈工具，用于为 AI 编程代理提供精准的代码定位信息。
- 📦 **安装与使用** – 通过 `npm install agentation -D` 安装，在 React 应用中引入 `<Agentation />` 组件即可使用。
- 🖱️ **核心功能** – 支持点击注释、文本选择、多选、区域选择、动画暂停、结构化输出（Markdown 格式）及深色/浅色模式。
- 🧠 **工作原理** – 自动捕获元素的类名、选择器和位置信息，生成如 `.sidebar > button.primary` 的精准选择器，替代模糊描述。
- 📄 **文档与许可** – 完整文档位于 agentation.dev，采用 PolyForm Shield 1.0.0 许可证。

## 更新

### [[repo] 初始化 Claude 配置 by rickhanlonii · Pull Request #35617 · facebook/react · GitHub](https://github.com/facebook/react/pull/35617)

React 仓库中新增了针对嵌套 /compiler 目录的 Claude 配置，通过巧妙的钩子机制实现根目录与编译器目录的配置隔离，并添加了多个针对 React 开发流程的专用技能命令。

- 🛠️ 新增了适用于嵌套 /compiler 目录的 Claude 配置，解决了根目录与编译器目录配置隔离的技术难题
- 🔧 通过 SessionStart 钩子动态加载配置，确保在 /compiler 目录工作时不会加载父级配置
- 📋 添加了 7 个 React 专用技能命令，包括错误提取、功能标志、代码修复、测试运行等开发工具
- ✅ 该拉取请求已获得两名核心成员批准并成功合并到主分支
- 📊 合并后进行了自动化构建和代码推送，未发现关键的生产包大小变化

## AI

### [译：Karpathy：关于 Claude 编程的笔记](https://sorrycc.com/karpathy-notes-on-claude-code)

本文是 AI 研究员 Andrej Karpathy 分享其近期深度使用 Claude 进行编程的体验与思考。他描述了工作流程从手动为主迅速转变为以 AI 智能体编程为主的根本性变化，分析了当前 AI 编程在效率、能力扩展和乐趣上的巨大优势，同时也指出了其存在的错误类型、代码质量及对开发者技能的可能影响。最后，他对未来工程师角色、技术发展及可能出现的“垃圾代码”泛滥等问题提出了前瞻性质疑。

- 🤖 **工作流剧变**：在几周内，我的编程模式从 80% 手动变为 80% 由 AI 智能体完成，本质上是在用英语“描述”编程。这是近 20 年职业生涯中最大的工作流变革。
- 👀 **需保持监督**：关于“不再需要 IDE”或“智能体集群”的炒作言过其实。模型仍会犯错，尤其是概念性错误，因此必须用大型 IDE 像鹰一样盯着它们生成的代码。
- 🔄 **错误类型转变**：错误不再是语法错误，而更像马虎的初级开发者犯的微妙概念错误，例如做出错误假设、过度迎合用户、不管理自身困惑感以及使代码抽象变得臃肿。
- 💪 **非凡的韧性**：智能体永不疲倦或气馁，能持续尝试直到成功。这种耐力极大地缓解了人类工作的核心瓶颈，带来了类似 AGI 的体验。
- 🚀 **能力扩展而非单纯加速**：LLM 辅助的主要影响不仅是速度提升，更是能力的扩展。我可以编写以前不值得或没能力写的代码，尝试以前无法触及的领域。
- 🎯 **声明式指令的杠杆作用**：最大的魔力在于给智能体设定成功标准（如“先写测试，然后通过测试”），让它循环工作直至达成目标，而不是一步步指挥它如何做。
- 😄 **编程变得更有趣**：大量繁琐的“填空”工作被移除，剩下更具创造性的部分，减少了卡壳感，增加了解决问题的勇气。
- ⚠️ **技能萎缩的担忧**：我注意到自己手动编写代码的能力正开始萎缩。虽然审查（判别）代码的能力仍在，但生成代码的肌肉记忆在退化。
- 📈 **对未来的预测与疑问**：我预计 2026 年将出现数字媒体领域的“垃圾代码大爆发”。同时，我思考着：LLM 会拉大还是缩小工程师间的生产力差距？全才会否优于专才？未来的编程会像玩策略游戏吗？
- 🌊 **阶段性转变已至**：2025 年 12 月左右，LLM 智能体能力跨越了关键阈值，引发了软件工程领域的阶段性转变。智能部分已领先于工具集成和工作流程优化，2026 年将是行业消化这种新能力的高能一年。

### [从编码者到编排者：AI 时代软件工程的未来](https://humanwhocodes.com/blog/2026/01/coder-orchestrator-future-software-engineering/)

本文概述了软件工程行业正在经历一场由 AI 驱动的根本性变革。人类正从代码的直接编写者，转变为 AI 编码代理的“指挥家”与“协调者”。这一转变将深刻影响开发工具、团队结构、工程师技能以及编程语言本身。以下是核心要点总结：

- 🚀 **从驾驶者到协调者**：AI 编程正从 2024 年的“增强型自动补全”（巡航控制），演进为 2025 年的“部分自主模型”（指挥家），再到 2025 年末出现的“全自主后台代理”（协调者）。未来，工程师将作为协调者，同时管理多个 AI 代理完成任务。
- 💻 **IDE 的焦点转移**：集成开发环境（IDE）正从以文本编辑为核心，转向以**管理 AI 代理任务**为核心。界面将突出代理会话状态（待处理、完成、卡住），便于工程师进行协调与整合，代码本身将退居后台。
- 🚫 **手动编码可能被禁止**：当 AI 编码优于人类时，尤其在自动驾驶、医疗、金融等高风险领域，手动编码可能因引入风险而被禁止。保险公司可能通过提高保费来推动这一转变，确保所有代码修改都通过能持续检查错误和安全问题的 AI 来完成。
- 🔍 **从代码审查员到任务验证者**：随着 AI 在编写和审查代码上都超越人类，工程师的角色将转变为**验证任务是否按需求完成**。审查将依赖代理生成的截图、视频等交付物，而非直接阅读源代码。
- 🗣️ **编程语言的演变**：当前为人类可读性设计的高级语言，其效用可能降低。未来可能出现**更节省 token、语法更紧凑的编程语言**，以提升 AI 生成代码的效率和降低成本。代码将主要为机器执行而写，人类可读变为次要。
- 👥 **最小化可行工程团队（MVET）**：单个工程师可协调多个代理，产出相当于多个工程师的代码，这将促使团队规模缩小。但基于协作需求、消除单点故障、专家知识等因素，**MVET 很少会是单人**。团队将更小，但结构更精干。
- 🎯 **从交付代码到交付价值**：未来软件工程师的核心技能将不再是编写代码，而是**组织、沟通、系统思维、模型选择、提示工程、输出验证、工作流调试、信息管理和预算管理**等。角色将更接近技术负责人，侧重于通过协调 AI 来创造价值。
- ⏳ **变革时间线**：基于协调者的开发模式预计在未来五年内（约 2028 年）被广泛采用，相关技能转变和团队重构也将同期基本完成。到 2030 年，许多新实践可能成为行业规范。

## 其他
