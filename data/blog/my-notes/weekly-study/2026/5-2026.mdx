---
title: 2026-第五周
date: '2026-02-01'
tags: ['WEEKLY-2026']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [React 编译器与为何类对象可能阻碍记忆化](https://anita-app.com/blog/articles/react-compiler-and-why-class-objects-work-against-memoization.html)

React Compiler 现已稳定并可用于生产环境，它显著减少了手动使用 `useMemo`、`useCallback` 和 `React.memo` 的需求。然而，对于依赖类实例和其方法计算派生值的代码模式，编译器的自动记忆化效果可能不佳，甚至可能因对象引用频繁变化而导致性能开销增加。文章建议在渲染逻辑中优先使用纯数据和纯函数，而非行为丰富的类实例，以提升编译器优化效果并减少手动记忆化的需要。

- 🚀 React Compiler 已稳定，可自动优化记忆化，减少手动使用 `useMemo`、`useCallback` 和 `React.memo`
- ⚠️ 类实例对象因其方法隐藏了实际依赖，可能导致编译器记忆化不精确，引发不必要的重新计算
- 🔍 React 的记忆化基于对象引用比较，若类实例引用频繁变化，即使内部数据未变也会触发重新渲染
- 🛠️ 可通过手动 `useMemo` 指定依赖项作为“逃生舱口”，但这会重新引入手动依赖管理并可能暴露内部数据
- 📊 推荐使用纯数据对象加纯函数的模式，使依赖关系显式化，便于编译器准确记忆化
- 🔄 传递原始值而非整个对象可避免因对象引用变化导致的不必要组件重渲染
- 🧩 在 React 渲染路径中，数据优先的模型通常能带来更好的自动记忆化命中率和更清晰的依赖推理
- 🎯 React Compiler 虽减轻了优化负担，但仍鼓励编写依赖关系明确的代码，以充分发挥其性能优势

### [性能并非技术问题](https://x.com/shuding/status/2013632751568851233)

本文作者基于在 Vercel 七年中处理约 400 个性能优化请求的经验，指出性能衰退的核心并非代码或工具问题，而是系统性的“熵增”——即软件在复杂化过程中自然走向混乱的趋势。作者认为，仅靠工程师的个人专注或更优工具无法根本解决该问题，因为代码库的扩展速度远超个人认知负荷，且抽象化设计常掩盖隐性成本。最终提出需建立**系统性规则与实时指导机制**，通过自动化模式检测与教育来对抗熵增，实现持久的高性能。

- 🧠 **性能问题本质是系统性熵增**：同样的性能错误在不同工程师、代码库和时期反复出现，表明问题根源在于系统复杂性而非个人技术能力。
- 📈 **代码库增长超越个人认知**：现代代码库的依赖、状态、异步流程呈指数级增长，工程师在切换功能时难以维持全局上下文，导致优化盲点。
- 🧱 **抽象化隐藏成本与风险**：文中列举四个案例（如全局监听器重复添加、缓存因引用相等性失效等），说明抽象设计常使性能代价变得不可见，且类型安全等工具无法阻止问题蔓延。
- ⏳ **被动优化无法持续**：等待应用“变慢”再修复是反应式做法，优秀产品需主动构建防性能衰退的系统。
- 🤖 **以系统化规则对抗熵增**：提出将常见错误转化为可查询、可维护的规则库，并通过自动化代理实时检测代码、解释问题并提供解决方案，从而弥补人类认知局限。
- 🌿 **性能如花园，需持续维护**：熵增必然发生，无法单靠意志力或补丁消除，唯有通过强制性的系统设计才能约束混乱，实现长期性能稳定。

### [AI 调试：能否替代经验丰富的开发者？](https://www.developerway.com/posts/debugging-with-ai)

本文通过三个真实案例测试了 AI 在调试 React/Next.js 应用中的表现，发现 AI 能有效解决模式化问题（如数据验证错误），但在需要深入理解系统原理或涉及复杂交互逻辑时，其诊断和修复能力有限，常产生错误或片面的解决方案。

- 🐛 **AI 能快速修复模式化错误**：在第一个案例中，AI 成功识别并修复了因 Zod 模式验证失败导致的页面错误，通过补充缺失字段解决了问题。
- 🔍 **AI 对复杂问题的诊断能力不足**：在第二个案例中，AI 未能准确识别双重加载问题的根本原因，其提出的解决方案虽能暂时消除问题，却可能引发新的错误。
- 🚫 **AI 难以处理非典型或深层逻辑问题**：在第三个案例中，AI 完全未能解决由服务器端重定向与 Suspense 边界内 Server Action 交互引发的错误，其多次尝试均基于错误假设。
- 🤖 **AI 适合辅助而非替代开发者**：AI 在调试中可作为有效的初步工具，尤其适用于常见错误模式，但开发者仍需深入验证其解决方案的正确性，并在复杂场景中依靠自身理解进行调试。

## 工具

### [tool-ui](https://github.com/assistant-ui/tool-ui)

Tool UI 是一个专为 AI 界面设计的开源 UI 组件库，基于 Radix、shadcn/ui 和 Tailwind 构建，具备响应式、可访问、类型化及可复用的特点。

- 🎛️ **审批卡片** — 为智能体操作提供二元确认
- 🔊 **音频组件** — 支持带封面和元数据的音频播放
- 📊 **图表组件** — 用交互式图表可视化数据
- 📚 **引用组件** — 展示带有来源归属的参考文献
- 💻 **代码块** — 显示语法高亮的代码片段
- 📋 **数据表格** — 支持列排序、行操作和移动端手风琴布局
- 🖼️ **图片组件** — 展示带有元数据和归属信息的图片
- 🖼️ **图片画廊** — 用于浏览图片集的网格布局
- 🎠 **项目轮播** — 用于浏览集合的水平轮播组件
- 🔗 **链接预览** — 利用 OG 数据生成丰富的链接预览
- ✅ **选项列表** — 支持单选/多选及响应式操作
- 🧾 **订单摘要** — 包含价格明细的购买确认清单
- 🎚️ **参数滑块** — 用于调整数值参数的控制组件
- 📋 **计划组件** — 展示分步任务工作流
- 📱 **社交帖子** — 渲染 X/Instagram/LinkedIn 帖子并提供媒体预览
- 🖥️ **终端组件** — 显示命令行输出和日志
- 📹 **视频组件** — 支持控件和封面图的视频播放

### [agent-trace](https://github.com/cursor/agent-trace)

Agent Trace 是一个用于追踪 AI 生成代码的开放规范，旨在为版本控制代码库提供一种记录 AI 贡献与人类作者身份的供应商中立格式。它通过标准化的 JSON 结构记录代码来源，支持细粒度的行级归属，并允许扩展自定义元数据，同时保持工具无关性和可读性。

- 🎯 **核心目标**：定义开放、可互操作的代码归属标准，支持文件与行级粒度，并允许供应商扩展元数据。
- 🤖 **贡献者类型**：区分人类（human）、AI（ai）、混合（mixed）和未知（unknown）四种代码贡献来源。
- 📄 **追踪记录结构**：基于 JSON 的模式，包含版本、ID、时间戳、版本控制系统信息、文件路径、对话链接及贡献者元数据。
- 🧩 **归属范围**：按对话分组记录代码行范围，支持通过内容哈希追踪代码移动，并关联模型标识符（遵循 models.dev 约定）。
- 🔗 **资源链接**：每个对话可包含原始对话 URL 及相关资源（如会话、提示）链接，便于追溯上下文。
- 🛠️ **扩展性**：通过元数据字段支持供应商特定数据，采用反向域名命名避免键名冲突，并遵循语义化版本控制。
- 📂 **存储与实现**：规范不限定存储方式（如本地文件、Git 笔记），提供参考实现示例，适用于各类 AI 编程代理。
- ⚠️ **非目标范围**：不涉及代码所有权、训练数据溯源、质量评估或特定界面要求，仅专注于归属记录。

### [GitHub - saneef/postcss-design-token-utils：将设计令牌转换为CSS自定义属性与实用工具类的PostCSS插件。](https://github.com/saneef/postcss-design-token-utils)

PostCSS 插件，用于将设计令牌转换为 CSS 自定义属性和实用类，支持分组、响应式变体和嵌套令牌。

- 🛠️ **功能概述**：PostCSS 插件，可将设计令牌（如颜色、间距）转换为 CSS 自定义属性和实用类，支持自定义前缀、分组和响应式变体。
- 🎨 **自定义属性生成**：通过 `@design-token-utils (custom-properties);` 在 CSS 中生成自定义属性，支持分组（如暗色主题）和媒体查询。
- 🧩 **实用类生成**：通过 `@design-token-utils (utility-classes);` 生成实用类（如背景颜色类），需在配置中指定令牌 ID、CSS 属性和类前缀。
- 📱 **响应式支持**：配置断点后，可为实用类生成响应式变体（如 `sm-bg-accent`），适配不同屏幕尺寸。
- 🌳 **嵌套令牌处理**：支持嵌套令牌结构（如 `color.gray`），自动合并父级和子级 ID 生成属性或类名。
- ⚠️ **注意事项**：实用类生成依赖自定义属性；使用 PurgeCSS 时需注意特殊字符类名的处理；插件配置灵活，可与其他工具集成。

### [node-av](https://github.com/seydx/node-av)

NodeAV 是一个为 Node.js 提供的原生 FFmpeg 绑定库，通过 N-API 直接访问 FFmpeg 的 C API，并具备完整的 TypeScript 支持。它提供了低层 API 用于完全控制，以及高层 API 和管道 API 简化常见任务。该库支持自动资源管理、硬件加速，并预置了 Windows、Linux 和 macOS 的二进制文件，适用于音视频处理、转码、流媒体处理等多种场景。

- 🎯 **核心功能** – 提供原生 Node.js FFmpeg 绑定，支持低层 API（直接调用 C API）和高层 API（简化操作），并包含完整的 TypeScript 类型定义。
- 📦 **资源管理** – 采用 Disposable 模式自动管理资源（如使用 `await using`），同时支持手动清理，避免内存泄漏。
- ⚡ **硬件加速** – 支持自动检测和指定硬件（如 CUDA、VAAPI），可提升编解码性能，并依赖系统 FFmpeg 构建和驱动。
- 🌐 **流处理** – 支持从文件、网络、缓冲区或自定义 I/O 回调读取数据，并能处理原始音视频数据（如 YUV、PCM）。
- 🎥 **设备捕获** – 支持跨平台（macOS、Linux、Windows）捕获摄像头、麦克风、屏幕内容，并可组合音视频流。
- 🔧 **FFmpeg 二进制访问** – 提供自动下载和管理的 FFmpeg 二进制文件，可直接调用 FFmpeg 命令行工具。
- 📚 **模块化导入** – 支持按需导入（tree shaking），可单独引入高层 API、低层 API、常量等，优化打包体积。
- 🚀 **高性能** – 执行效率接近原生 FFmpeg CLI，提供同步/异步操作选项，异步方法不阻塞事件循环，同步方法减少开销。
- 🛡️ **内存安全** – 高层 API 提供安全抽象，但低层 API 需

### [GitHub - facebook/lexical: Lexical 是一个可扩展的文本编辑器框架，提供卓越的可靠性、可访问性和性能。](https://github.com/facebook/lexical)

Lexical 是一个由 Meta 开发的开源、可扩展的文本编辑器框架，专注于可靠性、可访问性和高性能，提供丰富的功能与跨浏览器支持，并拥有活跃的社区。

- 🧩 **框架无关的核心** – 可与任何 UI 框架配合使用，并提供了官方的 React 绑定。
- ♿ **可靠且易于访问** – 内置无障碍支持，符合 WCAG 标准。
- 🔌 **高度可扩展** – 采用基于插件的架构，提供强大的扩展点。
- ⏳ **不可变状态模型** – 内置撤销/重做功能，支持时间旅行调试。
- 👥 **协同编辑** – 通过 Yjs 集成支持实时协作编辑。
- 📄 **序列化支持** – 支持从 JSON、Markdown 和 HTML 格式导入/导出内容。
- 🎨 **支持富文本内容** – 支持表格、列表、代码块、图像和自定义节点。
- 🌐 **跨浏览器兼容** – 支持 Firefox 52+、Chrome 49+、Safari 11+、Edge 79+。
- 🛡️ **类型安全** – 使用 TypeScript 编写，提供全面的类型定义。
- 🚀 **快速开始** – 可通过 npm 安装，并提供了简单的 React 集成示例。

### [coderio](https://github.com/MigoXLab/coderio)

CodeRio 是一款智能的 Figma 到代码自动化工具，通过多智能体系统将设计转换为生产就绪的 React 代码。它不仅生成代码，还提供视觉验证与校准，确保高保真度的 UI 还原，并支持断点续传和现代化代码架构，适用于前端开发者、团队和设计师加速开发流程。

- 🛠️ **智能设计协议生成** – 自动提取组件层次结构、样式和静态资源，生成符合前端开发规范的协议文件。
- 🎯 **视觉验证与校准** – 通过计算机视觉比对设计稿与生成页面，提供交互式差异报告，并自动迭代修正偏差。
- ⏸️ **断点续传功能** – 内置检查点系统，支持从中断处恢复运行，提高处理大型项目的稳定性。
- 📁 **生产就绪的代码结构** – 生成基于组件化架构、使用 React + TypeScript + Tailwind CSS 的代码，确保可维护性和响应式设计。
- 🚀 **多种使用方式** – 支持 CLI 一键生成和作为 Cursor/Claude Code 的 Skill 集成，适应不同开发场景。
- 🗺️ **持续发展路线图** – 计划支持增量开发、样式验证、多框架（Vue.js/Svelte）以及自定义设计系统集成。

### [nanobot](https://github.com/HKUDS/nanobot)

本文介绍了 `nanobot`，一个超轻量级的个人 AI 助手项目。它仅用约 4000 行代码实现了核心智能体功能，比同类项目体积小 99%，具有快速启动、低资源消耗、易于部署和扩展的特点。项目支持多种 LLM 提供商、本地模型部署、即时通讯集成（如 Telegram/WhatsApp），并提供了 Docker 容器化方案，适合研究、开发和个人使用。

- 🐈 **项目简介** - nanobot 是一个受 Clawdbot 启发的超轻量级个人 AI 助手，代码量仅约 4000 行，体积比 Clawdbot 小 99%。
- ⚡ **核心特点** - 具备研究友好、启动迅速、资源占用低、易于使用和修改的优势，支持一键部署。
- 🏗️ **功能范围** - 提供实时市场分析、全栈工程师辅助、智能日程管理、个人知识助手等多种能力。
- 📦 **安装方式** - 支持从源码、uv 工具或 PyPI 安装，并可配置多种 LLM 提供商（如 OpenRouter、Anthropic、本地 vLLM 等）。
- 🚀 **快速开始** - 通过 `nanobot onboard` 初始化配置，简单设置 API 密钥后即可通过命令行或聊天应用进行交互。
- 💬 **聊天集成** - 支持 Telegram 和 WhatsApp 通道，可随时随地与助手对话，并支持语音消息转文字（需 Groq 配置）。
- 🐳 **容器化部署** - 提供 Docker 镜像，方便通过容器运行并持久化配置。
- 📁 **代码结构** - 项目结构清晰，包含智能体核心、技能模块、消息总线、定时任务等组件，便于理解和贡献。

### [skillman](https://github.com/pi0/skillman)

本文介绍了 `skillman` 工具，它是一个用于管理项目 Agent 技能的命令行工具，通过读取和操作 `skills.json` 文件来安装、添加来自不同来源的技能。

- 🤹 **核心功能**：`skillman` 是一个用于管理项目 Agent 技能的工具，它基于 skills CLI，通过 `skills.json` 文件来集中管理技能。
- 📦 **安装技能**：运行 `npx skillman` 或 `npx skillman install` 即可安装 `skills.json` 中定义的所有技能。
- ➕ **添加技能**：使用 `npx skillman add <来源>` 命令可将新的技能源添加到 `skills.json` 并同时安装。支持多种来源格式，如 GitHub 仓库、skills.sh URL，并可指定具体技能名。
- ⚙️ **命令与选项**：主要命令包括 `install`（默认）和 `add`。支持 `--agent` 选项指定目标代理（如 claude-code），以及 `--global` 选项进行全局安装。
- 🔧 **开发与替代方案**：文档提供了本地开发设置步骤，并列举了其他相关的技能管理提案和工具作为替代方案。

### [OpenSandbox](https://github.com/alibaba/OpenSandbox)

OpenSandbox 是一个面向 AI 应用（如代码智能体、GUI 智能体、评估、代码执行等）的通用沙箱平台。它提供多语言 SDK、统一的沙箱 API，并支持 Docker 和 Kubernetes 运行时，便于实现大规模、分布式的沙箱环境管理与调度。

- 🧱 **核心定位**：一个为 AI 应用设计的通用沙箱平台，支持多种运行时和调度。
- 🔧 **核心功能**：提供多语言 SDK、统一的沙箱协议 API，并内置 Docker/Kubernetes 运行时支持。
- 🛠️ **内置环境**：默认提供命令行、文件系统和代码解释器环境，并示例展示了代码智能体、浏览器自动化和桌面环境集成。
- 🚀 **快速开始**：通过克隆仓库、启动服务、使用 SDK 即可快速创建沙箱并执行命令或代码。
- 📚 **丰富示例**：项目包含从基础操作到代码智能体集成、浏览器自动化及机器学习训练等多种场景的示例。
- 🏗️ **项目结构清晰**：目录结构明确，涵盖 SDK、服务端、运行时实现、示例及文档等模块。
- 🗺️ **持续发展**：项目已规划 Go SDK、Kubernetes 运行时增强、网络隔离等未来路线图，并在 Apache 2.0 协议下开源。

## 更新

### [限制单个网络请求 | 博客 | Chrome 开发者](https://developer.chrome.com/blog/throttle-individual-network-requests)

Chrome 145 开发者工具新增了“请求条件”功能，允许对单个网络请求进行独立限流或拦截，从而更精确地模拟特定资源（如缓慢的第三方 API 或大图）的加载情况，而无需降低整个页面的速度。

- 🛠️ **功能升级**：从 Chrome 145 开始，开发者工具支持对单个网络请求应用特定的网络限流条件，同时保留了拦截请求的能力，使调试更精准高效。
- 🎯 **操作方式**：在“网络”面板中右键点击任一请求，可选择“拦截请求”或“限流请求”，操作会自动打开“请求条件”面板并创建相应规则。
- ⚙️ **条件设置**：在“请求条件”面板中，可使用预设（如慢速 3G）或自定义配置来限流，并通过通配符（\*）编辑 URL 模式以匹配动态资源或请求组。
- 🔝 **规则优先级**：若请求匹配多个规则，开发者工具会应用最先找到的规则；可通过面板中的箭头按钮调整规则优先级顺序。
- 🚦 **识别状态**：被拦截的请求在“网络”面板中显示为红色，状态列为“(blocked:devtools)”；被限流的请求显示为黄色/金色，并在“时间”列带有时钟图标，悬停可查看具体限流条件。
- 📊 **性能影响**：限流可能影响页面性能；在录制性能分析时，可将鼠标悬停在“网络”轨道中的请求上，查看工具提示以了解应用的网络条件详情。

### [Astro 5.17 | Astro](https://astro.build/blog/astro-5170/)

Astro 5.17 版本引入了多项新功能和改进，包括可配置的开发工具栏位置、文件加载器的异步解析支持、分区化 Cookie、图像优化的背景色和内核选择，以及用于减少数据存储大小的新选项。

- 🛠️ **可配置开发工具栏位置**：新增 `devToolbar.placement` 配置选项，允许设置项目级的默认工具栏位置，避免与页面底部元素冲突。
- ⚡ **文件加载器支持异步解析**：`file()` 加载器的 `parser` 选项现在支持异步函数，便于在加载数据时执行复杂操作，如获取额外数据。
- 🍪 **分区化 Cookie 支持**：通过 `Astro.cookies.set()` 的 `partitioned` 选项，支持在嵌入场景中设置分区化 Cookie，增强隐私控制。
- 🎨 **图像转换背景色控制**：新增 `background` 属性，允许在将图像转换为不支持透明度的格式时指定背景颜色。
- 🔍 **Sharp 内核选择**：Sharp 图像服务新增 `kernel` 配置选项，可精细控制图像缩放算法，优化图像质量。
- 📦 **glob() 加载器的 retainBody 选项**：通过设置 `retainBody: false`，可减少大型内容集合的数据存储大小，提升部署效率。
- 🔧 **升级指南**：推荐使用 `@astrojs/upgrade` CLI 工具或手动运行包管理器命令升级到最新版本。
- 🐛 **错误修复**：包含自 5.16 版本以来的多项问题修复，详细内容可查看更新日志。

## 其他

### [领导风格中的自主性与明确性](https://bjorg.bjornroche.com/management/autonomy-vs-clarity/)

本文探讨了有效的领导力并非依赖于单一风格，而在于根据具体情况灵活运用不同的方法。文章提出了五种主要的领导风格（自主型、参与型、政策型、信念型和共识型），并分析了每种风格的特点、适用场景及潜在陷阱。核心观点是，优秀的领导者应像一个拥有多种工具的木匠，懂得针对不同问题（如所需协调程度、决策重复性、背景信息完整性等）选择合适的领导工具，以在团队自主性和目标清晰度之间取得最佳平衡。

- 🧰 **灵活运用领导风格**：有效的领导力不在于坚持单一方法，而在于根据具体情境从多种风格（自主、参与、政策、信念、共识）中选择最合适的一种。
- 🧭 **自主型领导**：通过设定北极星目标并逐层分解，赋予团队高度自主权。适用于可分解且无需大量协调的问题，是中型及以上组织的默认高效工作方式。
- 🔍 **参与型领导**：领导者深入团队日常工作和细节，适用于自身是产品/领域专家且需跨层级协作的情况。但需避免 micromanagement，并注意自身精力与知识的局限。
- 📜 **政策型领导**：通过制定清晰、简单的政策来规范重复性决策（如招聘、晋升），能提高效率与一致性。但政策需保持灵活，明确例外情况和升级路径，以防官僚主义。
- 🎯 **信念型领导**：当需要顶层协调和战略时，领导者在充分理解所有背景信息后做出决策并全力争取团队认同。关键在于决策正确且能有效传达理由以获得支持。
- 🤝 **共识型领导**：当决策需要广泛协调且无人掌握全部信息时，通过汇集各方意见达成共识。能获得深度认同，但需避免“假共识”，且不适用于所有快速决策场景。

### [有时你的职责就是彻底别碍事](https://randsinrepose.com/archives/sometimes-your-job-is-to-stay-the-hell-out-of-the-way/)

本文探讨了“狼型工程师”（即 10 倍高效工程师）的真实存在与管理启示，强调真正的“狼”专注于自选的重要项目，其动力源于工作本身，而非头衔或认可。管理者不应强行塑造或过度干预，而应构建专注、无干扰的工程文化，并在关键时刻“让路”，以保护创新。

- 🐺 “狼型工程师”真实存在，他们不自知也不在乎标签，只专注于自选的重要项目。
- 🏢 吸引“狼”的关键是构建专注、无干扰的工程文化，而非空谈“10 倍效率”。
- ⚠️ 强行创建“狼”角色或流程可能适得其反，导致真“狼”离职或出现模仿者。
- 🚀 案例中，工程师理查德自主开发测试框架，管理者仅轻微支持并避免干预，项目最终成功。
- 🛡️ 管理者的关键职责之一：识别重要工作，并在必要时“坚决不插手”以保护创新。
- 🔍 “狼”的工作成果能自我证明，并激励团队主动参与，提升整体效能。

### [担任工程经理十年间我所领悟到的事](https://www.jampa.dev/p/lessons-learned-after-10-years-as)

本文是一位资深工程经理的经验分享，核心观点是工程经理的角色没有固定定义，其职责应根据团队实际需求在**产品、流程、人员、编程**四大支柱间动态调整。文章强调了经理需保持灵活性，避免成为团队瓶颈，并着重探讨了如何关注产品价值、优化流程、建立团队信任以及进行有效向上管理。

- 🧭 **角色无定式**：工程经理的职责并非一成不变，它完全由团队的具体需求决定，需要在产品、流程、人员和技术（编程）四大支柱间灵活平衡。
- 🎯 **产品价值至上**：团队的核心是交付用户价值，而非仅仅编写代码。即使有产品经理，整个工程团队也必须深入理解并关心所要解决的实际问题。
- ⚙️ **流程服务于人**：流程是为了保障可靠性与质量，但需警惕“流程膨胀”。应持续审视流程的必要性，避免其演变为僵化的仪式，反客为主。
- 👥 **信任与透明**：与下属建立信任至关重要，透明沟通是基础。经理应像“透明雨伞”，既保护团队免受不必要的干扰，也不隐瞒会影响他们的现实情况。
- 🧠 **向上管理需准备**：向高层汇报时，应提供清晰的背景、问题、计划/方案以及所需支持，而非简单抛问题。高层需要的是决策建议，而非信息倾倒。
- 📊 **经理的三重角色**：理想的时间分配应是**队员（10%，处理非关键路径工作）、教练（30%，指导与纠正行为）、啦啦队长（60，认可与鼓励团队）**。
- 🚧 **避免成为瓶颈**：经理必须有意识地授权和培养团队，确保自己不在时工作仍能顺利推进。不能让自己成为单点故障（巴士因子为 1）。
- 🔍 **信任但需核实**：管理基于信任，但需要通过定性和定量结合的方式了解进展。定性洞察（如协作精神、沟通能力）更能体现经理的价值。
- 🐄 **项目如牲畜**：对经理而言，所有项目都应像管理牲畜一样，目标明确：完成、自动化、委派或取消。不应因舒适、恐惧或身份认同而紧抓具体技术项目不放。
- ⚖️ **规避风险需适度**：在招聘等环节过度规避风险（如增加过多面试轮次）可能产生反效果，导致责任稀释并错失优秀人才。应追求高效、精准的评估。

---

AI 带来的问题，不在于机器人即将到来，而在于你不知道自己究竟应该擅长什么。

-- 《你的工作并没有消失，只是不断缩小》

---

AI 公司总是说，由于他们的工具，人们可以专注于更高价值的工作。但是，没人能够定义，高价值工作究竟是什么工作。

-- 《你的工作并没有消失，只是不断缩小》
