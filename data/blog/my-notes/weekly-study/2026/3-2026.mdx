---
title: 2026-第三周
date: '2026-01-18'
tags: ['WEEKLY-2026']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [Shadcn 单选按钮令人难以置信的过度复杂性](https://paulmakeswebsites.com/writing/shadcn-radio-button/)

作者在尝试更新网页应用中的单选按钮样式时，发现项目使用了 Shadcn 组件库中的复杂 React 组件，这引发了对现代前端开发过度复杂化的反思。通过分析 Shadcn 依赖 Radix UI 库的实现方式，揭示了用 ARIA 角色模拟原生 HTML 元素的反模式，并对比了仅用 CSS 轻松定制样式的简洁方案。文章批判了当前为简单交互引入多层抽象导致的性能负担和认知负荷，倡导回归浏览器原生元素的简洁与高效。

- 🎨 **样式定制本可简单**：仅需 CSS 的`appearance: none`和伪元素即可完全自定义单选按钮样式，无需 JavaScript 或额外依赖
- 🏗️ **层层抽象增加复杂度**：Shadcn 基于 Radix UI 构建，两个库叠加导致理解单个组件需阅读数百行代码
- ⚠️ **违反无障碍最佳实践**：用 ARIA 角色将按钮模拟成单选按钮，违背“优先使用原生语义元素”的 WAI-ARIA 第一准则
- 📦 **隐性性能成本**：为渲染简单控件需加载第三方图标库和大量 JavaScript，增加页面体积与解析时间
- 🔄 **历史遗留问题已解决**：跨浏览器样式不一致问题多年前已通过标准 CSS 方案解决，复杂重构不再必要
- ⚖️ **开发便利的代价**：组件库虽降低 CSS 学习成本，但引入了依赖管理、版本升级和抽象泄漏等新问题
- 🌐 **原生元素的优雅**：`<input type="radio">`作为 30 年历史的浏览器原生元素，兼具语义完整、零依赖与即时渲染优势

### [构建 docfind：利用 Rust 与 WebAssembly 实现快速客户端搜索](https://code.visualstudio.com/blogs/2026/01/15/docfind)

本文讲述了 VS Code 团队开发的一款名为 docfind 的浏览器内搜索引擎的诞生故事。它利用 WebAssembly、有限状态转换器（FST）和压缩技术，为静态网站提供快速、紧凑、无需服务器的客户端搜索体验。

- 🚀 **目标与挑战**：作者希望为 VS Code 官网打造一个类似其编辑器内“快速打开”功能的即时搜索体验，但现有方案（如 Algolia、Lunr.js）在客户端性能、索引大小或维护性上均不理想。
- 💡 **技术灵感**：项目灵感来源于一篇关于使用有限状态转换器（FST）高效索引海量字符串的博客，并融合了 RAKE 关键词提取算法和 FSST 字符串压缩技术。
- 🔧 **解决方案：docfind**：开发了一个 Rust 编写的 CLI 工具，它能在网站构建时，将文档转换为一个集成了索引数据的单一 WebAssembly 模块，供浏览器直接使用。
- 🧩 **核心技术实现**：索引结构结合了 FST（用于快速关键词查找）、压缩存储的文档字符串以及关键词到文档的映射。搜索时支持前缀匹配和 Levenshtein 自动机（容错匹配）。
- ⚙️ **关键难题**：最大的挑战是如何将动态生成的索引数据“嵌入”到预编译的 WebAssembly 模板中，这涉及对 WASM 二进制格式的解析、内存段修补和全局变量替换。
- 🤖 **AI 助力开发**：作者强调，在时间有限且不精通 Rust 和 WASM 底层细节的情况下，GitHub Copilot 在技术研究、代码编写（特别是绕过借用检查器）、项目脚手架和攻克 WASM 修补难题上起到了关键作用，是项目得以完成的重要因素。
- 📊 **成果展示**：docfind 已成功应用于 VS Code 官网，处理约 3700 份文档，索引压缩后仅约 2.7MB，每次查询耗时约 0.4 毫秒，实现了无需服务器、无持续成本的快速搜索。
- 📦 **开源与使用**：项目已开源，用户可通过简单命令安装，并为自己的静态网站生成搜索模块，只需自行实现前端结果展示界面即可。

### [译：我的 AGENTS.md 文件](https://sorrycc.com/my-agents-md-file)

本文介绍了“规划循环”这一关键方法，它能将 AI 从一个不可靠的代码生成器转变为高效的编程伙伴。该方法通过一个结构化的四步流程（规划、执行、测试、迭代），强制要求开发者在编码前与 AI 明确方案，从而显著提升 AI 生成代码的质量和可靠性。

- 🤔 **转变观念**：开发者起初对 AI 编码持怀疑态度，但“规划循环”技术改变了一切，使其成为不可或缺的伙伴。
- 🔄 **核心流程**：规划循环包含四个步骤：1. 与 AI 共同规划方案；2. 执行规划编写代码；3. 共同测试验证；4. 提交并迭代。
- ⚠️ **规划重要性**：跳过规划步骤会导致 AI 猜测意图，引发幻觉和误解；规划能强制明确需求，使 AI 工作更轻松，代码质量更高。
- 📝 **规划准则**：有效的规划需极其简洁，可牺牲语法以求简明，并在结尾列出待解决的未决问题。
- 🛠️ **实践工具**：作者提供了可加入`CLAUDE.md`或`AGENTS.md`文件的规则模板，以及一个自动将其添加到配置文件的脚本。

### [译：使用 Agent 编程的最佳实践](https://sorrycc.com/agent-best-practices)

本文概述了使用 Cursor Agent 进行 AI 辅助编程的最佳实践。文章强调，要充分发挥编程 Agent 的潜力，需要理解其工作原理并采用新的协作模式。核心在于将 Agent 视为有能力的合作者，通过清晰的计划、有效的上下文管理、自定义规则与技能，以及结合测试和审查，来提升开发效率和代码质量。

- 🧠 **从计划开始**：在编码前使用“计划模式”（Shift+Tab），让 Agent 先研究代码库、提出澄清问题并制定详细实施计划，经批准后再执行。
- 🔄 **灵活管理对话与上下文**：根据任务逻辑单元决定开始新对话或继续当前对话；利用 `@Branch`、`@Past Chats` 等工具让 Agent 自主寻找所需上下文，避免提示词冗余。
- 📜 **使用规则（Rules）提供静态指导**：在 `.cursor/rules/` 中创建 Markdown 文件，定义项目核心命令、代码风格和工作流模式，引导 Agent 行为并团队共享。
- 🛠️ **利用技能（Skills）扩展动态能力**：通过 `SKILL.md` 文件定义可重用的命令、钩子脚本和领域知识，使 Agent 能在相关时动态调用，实现如“运行直到测试通过”的长时间循环任务。
- 🖼️ **结合图像输入进行设计与调试**：直接向 Agent 粘贴设计原型图以生成匹配代码，或截图进行视觉调试，比文字描述更高效。
- ✅ **采用测试驱动开发（TDD）等模式**：明确指示 Agent 遵循 TDD 流程（先写失败测试，再实现代码），或让其协助理解代码库、自动化 Git 工作流（如 `/pr` 命令）。
- 👁️ **重视代码审查**：在 Agent 生成过程中实时观察 Diff，完成后使用“审查”功能或推送到 PR 利用 Bugbot 进行自动分析，确保代码质量。
- ⚡ **并行运行与云端委派**：可同时运行多个模型或 Agent 在独立 worktree 中解决同一问题，择优选择；也可将任务委派给云端 Agent，在后台处理并自动提交 PR。
- 🐛 **启用调试模式解决棘手问题**：对于可复现但难定位的 Bug，让 Agent 生成假设、插入日志、收集运行时数据并基于证据进行针对性修复。
- 🎯 **建立高效协作工作流**：编写具体、可验证的提示词；逐步迭代配置而非过度优化；将 Agent 视为合作者，主动索要计划、解释并主导审查过程。

### [你能用 React 服务器操作获取数据吗？](https://www.developerway.com/posts/server-actions-for-data-fetching)

本文探讨了是否可以使用 React Server Actions（现称 Server Functions）进行客户端数据获取。虽然技术上可行，但存在性能问题，特别是并行请求会变成串行处理，导致数据加载时间显著增加。因此，不建议将其用于数据获取，而应使用传统的 REST 请求配合数据获取库（如 TanStack Query）。

- 🚫 **不适用于数据获取**：Server Actions 本质上是 POST 请求的封装，虽然可实现类型安全，但设计初衷并非用于获取数据。
- ⚠️ **性能问题**：在大型应用中，使用 Server Actions 获取数据会导致并行请求转为串行，大幅延长加载时间（例如从 1.7 秒增至 8 秒）。
- 🔍 **调试困难**：网络面板中所有请求名称相同，且响应格式不易阅读，增加了调试复杂度。
- 🛡️ **缓存限制**：POST 请求无法通过 HTTP 头部进行浏览器或 CDN 缓存，但客户端缓存（如 TanStack Query）仍可正常使用。
- 🔄 **替代方案**：客户端数据获取应使用简单的 REST 请求配合数据获取库，而非 Server Actions 或过度依赖 Server Components。
- 📊 **性能对比**：实验显示，传统 fetch 方式在数据可见时间上（1.7 秒）远优于 Server Actions（8 秒），而 SSR 和 Server Components 各有优劣。
- 💡 **学习建议**：开发者应掌握服务端渲染（SSR）、Server Components 及数据获取的基础原理，结合实际需求选择合适方案。

### [扩展长时间运行的自主编码能力](https://cursor.com/cn/blog/scaling-agents)

本文概述了通过并行运行数百个智能体（Agent）来推进自主编码项目的研究，旨在探索智能体在长期复杂任务（如从零构建浏览器）中的极限。实验表明，通过角色划分（规划者与执行者）和优化协调机制，智能体能够协同工作数周，生成超百万行代码，并取得实质性进展。

- 🚀 **目标与规模**：研究旨在通过数百个并发智能体推进自主编码前沿，在长期复杂项目上测试极限，已实现生成超百万行代码和数万亿 token。
- 🔄 **协调机制演进**：从平等的动态协调（使用锁机制）转向“规划者 - 执行者”流水线结构，解决了协同瓶颈和任务规避问题，实现了高效并行。
- 🏗️ **角色分工**：规划者负责探索代码库并创建任务，执行者专注完成任务，结合定期评审和重置机制，确保系统稳定且可扩展。
- 🌐 **实验成果**：智能体成功从零构建浏览器、迁移大型代码库（如 Solid 到 React）、优化产品性能（如视频渲染提速 25 倍），并在多项长期项目中持续运行。
- 🧠 **关键洞察**：模型选择至关重要（如 GPT-5.2 更适合长期任务），简化系统优于过度设计，提示词工程对智能体行为影响显著，且多智能体协同仍具挑战但前景乐观。
- 🔮 **未来方向**：优化智能体唤醒机制和抗漂移能力，逐步将技术集成至 Cursor 平台，以持续提升自主编码效率。

### [620 - “Agent Browser”](https://sorrycc.com/agent-browser)

本文介绍了 Agent Browser 这一由 Vercel Labs 开发的 AI 浏览器自动化工具。它通过生成页面的可访问性树并为元素提供唯一引用，使 AI 能够精准控制浏览器操作。文章详细说明了其安装、基本工作流、如何连接本地 Chrome 以利用登录状态、内置 Skills 功能以及如何结合 undetected_chromedriver 绕过网站自动化检测，适用于多种网页自动化场景。

- 🚀 **工具介绍**：Agent Browser 是 Vercel Labs 开发的 Rust 构建的 CLI 工具，专为 AI Agent 设计，通过输出页面的可访问性树和元素唯一引用，让 AI 能准确控制浏览器交互。
- ⚙️ **快速上手**：安装后可通过 `open` 命令打开网页并生成快照，使用 `click` 或 `fill` 等指令与页面元素交互，每个元素都有类似 `@e2` 的唯一标识。
- 🔗 **连接本地 Chrome**：支持通过 Chrome DevTools Protocol 连接已运行的浏览器实例，利用现有登录状态（如 Cookie、账号信息），实现更实用的自动化操作（如发推、管理 GitHub）。
- 🛠️ **Skills 功能**：提供预置 Skills，可与 AI 结合自动执行复杂任务，例如获取并总结 Hacker News 上 AI 相关的内容，或操作 Gmail 发送邮件。
- 🕵️ **绕过检测**：可接入 undetected_chromedriver 启动带调试端口的 Chrome，避免被网站识别为自动化工具，适用于反爬虫、自动注册等灰色地带场景。

### [Browser Extension Dev - 03. 注入 UI](https://blog.rxliuli.com/p/5cb6d59a968a449b9fa2c003b9f4c48a/)

本文详细介绍了如何使用 WXT 框架、React、Tailwind CSS 和 shadcn 组件库，在 YouTube 页面中注入一个复杂的 UI 扩展，以实现视频截图功能。文章通过一个具体的“YouTube 视频截图扩展”示例，逐步讲解了如何解决样式冲突、框架注入、图标嵌入、视频帧捕获、图片复制到剪贴板以及自动下载等关键问题。

- 🎯 **项目目标**：创建一个 YouTube 视频截图扩展，将图标注入视频播放器工具栏，点击后可截取当前视频帧、复制到剪贴板并自动下载。
- 🛠️ **技术栈与初始化**：使用 WXT 初始化 React 模板项目，并配置 Tailwind CSS 和 shadcn 组件库，手动完成相关依赖安装和配置。
- 🎨 **样式隔离方案**：通过 Shadow DOM 模式注入 UI，有效隔离扩展样式与网页样式，避免了 Tailwind CSS 可能引发的样式冲突。
- ⚛️ **框架注入原理**：React 等现代前端框架在构建时会被打包到 Content Script 中，随脚本一同注入页面，因此可以在扩展中使用任意 JavaScript 框架。
- 🔧 **图标注入与资源访问**：通过定位 YouTube 播放器工具栏的特定容器元素，将自定义按钮注入其中，并需在 manifest 中配置 `web_accessible_resources` 以允许网页访问扩展图标资源。
- 📸 **截图功能实现**：利用 Canvas API 的 `drawImage` 方法捕获视频当前帧，生成图片 Blob。
- 📋 **复制与下载功能**：使用 Clipboard API 将图片 Blob 复制到剪贴板，并借助 `file-saver` 和 `dayjs` 库实现带时间戳的文件自动下载。
- ⚠️ **注意事项与局限**：文中提及了未处理的边缘情况，如视频未播放、广告处理、异常捕获等，但核心流程已完整实现。

## 工具

### [shimmer-from-structure](https://github.com/darula-hpp/shimmer-from-structure)

Shimmer From Structure 是一个创新的 React 骨架屏加载库，它通过运行时分析组件的实际 DOM 结构，自动生成与之完美匹配的骨架效果。相比传统骨架屏库需要手动创建和维护骨架组件，该库实现了零维护、自适应布局变化，并支持动态数据和复杂嵌套结构，大幅提升了开发效率和用户体验。

- ✨ **自动适配组件结构** – 运行时分析组件 DOM，生成与真实布局完全匹配的骨架效果，无需预定义骨架结构。
- 🔄 **零维护成本** – 布局变化时自动适应，无需同步更新骨架组件，告别手动维护。
- 🎯 **动态数据支持** – 通过 `templateProps` 提供模拟数据，确保动态内容在加载时也能准确测量和渲染。
- 🎨 **智能样式继承** – 自动检测 CSS 边框圆角，保持容器背景可见，默认颜色适配深色/浅色模式。
- ⚙️ **灵活配置** – 支持全局配置（通过 `ShimmerProvider`）和局部属性覆盖，可自定义颜色、动画时长等。
- ⚡ **高性能实现** – 仅在加载状态变化时进行同步 DOM 测量，使用原生 API 确保无闪烁和最小重渲染。
- 🔧 **无缝集成 Suspense** – 可直接作为 React Suspense 的 fallback，简化代码逻辑。
- 📦 **轻量易用** – 通过 npm/yarn/pnpm 安装，提供静态和动态用法的清晰示例。

### [Scenetest](https://scenetest.github.io/scenetest-js/)

Scenetest 是一个面向 Vite 应用的本地优先测试框架，旨在直接测试应用的实际数据状态与用户心智模型，而非仅模拟用户操作。它通过将类型安全的断言直接嵌入 React 组件、钩子与副作用中，实现多上下文（如本地状态与数据库）的自动对比，从而更精准地验证应用逻辑。框架利用类似 Server Actions 的模式，在开发与测试环境中运行断言，在生产环境中则完全移除，确保零运行时开销。

- 🎯 **测试理念革新** – 传统测试依赖 DOM 与数据库的“两端验证”，但现代应用的核心数据常驻于本地缓存或状态库中，需直接测试本地状态与预期的同步性。
- 🔧 **嵌入式断言** – 通过 `should`、`failed`、`assert` 等函数在组件生命周期内编写类型安全的断言，自动验证数据一致性，无需暴露内部状态给测试运行器。
- 🧩 **场景化测试** – 使用 `scene` 定义用户操作流程（如登录、修改资料），专注于用户旅程的编排，而非技术实现细节。
- 🔄 **多上下文对比** – 利用 `assert` 函数在客户端与服务器间直接比较数据，避免通过 `window` 对象“暴力提取”状态，使测试更自然且可复用。
- 🚀 **零生产开销** – 通过 Vite 插件在构建时剥离测试代码，仅在生产环境中移除断言逻辑，开发与测试阶段则持续收集验证结果。
- 🌱 **早期项目阶段** – 目前处于侧项目开发初期，鼓励开发者通过 GitHub 或社交媒体反馈意见。

### [composify](https://github.com/composify-js/composify)

Composify 是一个开源 React 库，为您的应用添加可视化编辑器。它允许非开发人员使用您现有的生产组件构建页面，从而让工程师能专注于实际功能开发。它在僵化的通用页面构建器和复杂的无头 CMS 之间提供了折中方案，是一个直接操作您真实组件代码的可视化界面。

- 🎯 **定位清晰** - Composify 是一个开源 React 库，旨在为现有 React 组件添加可视化编辑能力，让非开发者也能构建页面。
- ⚖️ **折中方案** - 它介于僵化的通用页面构建器（如 Wix）和需要适配代码的复杂无头 CMS（如 Builder.io）之间，直接使用您自己的组件。
- 🚀 **快速开始** - 通过 npm 等工具安装，注册组件到目录后，即可使用 `Renderer` 渲染或 `Editor` 进行可视化编辑。
- 🔧 **工程师友好** - 工程师只需一次性注册组件，定义其可配置属性，团队其他成员即可在编辑器中拖放使用，设计系统得以保持。
- 🌐 **环境兼容** - 作为一个 React 库，可与 Next.js、Remix 等任何 React 环境配合使用，且您完全拥有自己的数据。
- ⚡ **核心优势** - 支持无需重新部署即可更新 UI、让非开发者团队自主进行页面组合与调整，并便于进行 A/B 测试和快速原型开发。
- ☁️ **云服务选项** - 除了开源库，还提供 Composify Cloud，包含托管、实时协作和版本历史等托管后端功能。

### [localspace](https://github.com/unadlib/localspace)

localspace 是一个现代化的存储工具包，它在保持与 localForage API 完全兼容的同时，采用了 async/await、TypeScript 等现代技术，并消除了遗留包袱。它旨在为现代应用提供强类型、更好的异步编程体验、多平台可靠性以及一系列新功能，而无需重写现有代码。

- 🎯 **核心目标**：提供与 localForage 完全兼容的 API，同时内部使用现代 TypeScript 和原生 Promise 重构，以解决社区长期存在的痛点。
- 🛠️ **现代特性**：提供一流的 TypeScript 类型支持、原生 async/await、可靠的 IndexedDB 清理、跨平台一致性、批量操作、TTL（生存时间）和加密等。
- 🔄 **无缝迁移**：允许团队在不更改应用代码的情况下从 localForage 迁移，然后解锁更好的开发者体验和未来可扩展性。
- 🚀 **性能优化**：提供可选的“合并写入”功能，可将高频写入操作批量处理，使 IndexedDB 写入性能提升 3-10 倍。
- 📦 **批量操作**：支持 `setItems()`、`getItems()`、`removeItems()` 等批量 API，通过单次事务处理提高吞吐量。
- 🔌 **插件系统**：提供模块化的插件架构，支持 TTL、加密、压缩、多标签页同步和配额管理等高级功能。
- 🌐 **多平台支持**：支持浏览器、Node.js、React Native 和 Electron 等多种环境，并计划集成更多驱动（如 OPFS、SQLite）。
- ⚙️ **灵活配置**：允许创建独立的存储实例、自定义驱动顺序、配置写入一致性模式和使用存储桶进行数据隔离。
- 🛡️ **错误处理**：提供结构化的错误类型和详细的上下文信息，便于调试和问题排查。
- 📈 **开发路线图**：核心兼容性已完成，未来将重点开发插件系统、新驱动集成（如 OPFS、Node.js 适配器）和社区优先的功能。

### [resolvers](https://github.com/react-hook-form/resolvers)

`@hookform/resolvers` 是一个为 React Hook Form 提供验证解析器的官方库，它允许开发者无缝集成各种外部验证库（如 Yup、Zod、Joi 等）或自定义验证逻辑，以实现高性能、灵活且可扩展的表单验证。

- 📦 **核心功能**：作为 React Hook Form 的官方桥梁，支持集成超过 15 种主流验证库，包括 Yup、Zod、Joi、Vest、Ajv、TypeBox 等。
- 🛠️ **安装简单**：通过 npm、yarn、pnpm 或 bun 安装 `@hookform/resolvers` 及所需的验证库即可快速开始。
- 🧩 **TypeScript 友好**：大多数解析器能自动从验证模式（schema）推断类型，提供完整的类型安全支持。
- ⚙️ **统一 API**：所有解析器遵循一致的 `resolver(schema, schemaOptions?, resolverOptions?)` 调用方式，支持同步或异步验证模式。
- 📚 **详尽示例**：为每种支持的验证库提供了完整的代码示例，展示如何与 React Hook Form 的 `useForm` 结合使用。
- 🔗 **官方文档**：提供了与 React Hook Form 验证解析器相关的详细文档链接，方便深入查阅。
- 🌍 **社区支持**：项目拥有活跃的社区贡献者、赞助者，并采用 MIT 开源协议，鼓励参与和协作。

### [ai-elements](https://github.com/vercel/ai-elements)

AI Elements 是一个基于 shadcn/ui 构建的组件库，旨在帮助开发者快速构建 AI 原生应用。它提供了一系列专为 AI 应用设计的可定制 React 组件，并支持通过 CLI 工具轻松集成到 Next.js 项目中。

- 🧩 **组件库定位**：基于 shadcn/ui 的 AI 原生应用组件库，提供对话、消息、代码块、推理展示等预制组件。
- ⚙️ **安装方式**：可通过 `npx ai-elements@latest` 直接安装，或使用 shadcn CLI 添加特定组件。
- 📋 **前提条件**：需要 Node.js 18+、已安装 AI SDK 的 Next.js 项目、已初始化的 shadcn/ui 以及配置为 CSS 变量模式的 Tailwind CSS。
- 🧠 **组件功能**：包含聊天机器人、代码块、推理展示、工作流可视化等 20 多个组件，覆盖 AI 应用常见交互场景。
- 🚀 **快速使用**：安装后可直接在 React 应用中调用组件，并支持与 AI SDK 的 `useChat` 等钩子集成。
- 🔧 **定制化支持**：组件将安装到本地代码库中，允许开发者完全自定义样式和逻辑。
- 🌐 **推荐配置**：建议搭配 Vercel AI Gateway 和 CSS 变量模式使用，以获得最佳体验。

## 更新

### [模块：node:module API | Node.js v25.4.0 文档](https://nodejs.org/api/module.html#module-compile-cache)

Node.js v25.4.0 文档中关于 `node:module` API 的详细说明，提供了模块系统的高级定制和实用功能。

- 📦 **模块对象**：提供与 `Module` 实例交互的通用工具方法，可通过 `import 'node:module'` 或 `require('node:module')` 访问。
- 📜 **内置模块列表**：`module.builtinModules` 返回 Node.js 提供的所有模块名称列表，用于区分核心模块与第三方模块。
- 🔗 **创建 require 函数**：`module.createRequire(filename)` 根据指定文件路径构造一个 `require` 函数，支持文件 URL 或绝对路径。
- 📁 **查找 package.json**：`module.findPackageJSON(specifier[, base])` 根据模块说明符查找最近的 `package.json` 文件路径。
- ✅ **检查内置模块**：`module.isBuiltin(moduleName)` 判断给定模块名是否为 Node.js 内置模块。
- ⚙️ **注册异步钩子**：`module.register(specifier[, parentURL][, options])` 注册导出异步钩子的模块，用于定制模块解析和加载行为（需注意线程间通信开销）。
- 🔧 **注册同步钩子**：`module.registerHooks(options)` 直接注册同步钩子函数，在加载模块的同一线程中运行，推荐使用以简化操作。
- 🧹 **剥离 TypeScript 类型**：`module.stripTypeScriptTypes(code[, options])` 移除 TypeScript 代码中的类型注解，并可选择转换为 JavaScript。
- 🔄 **同步内置 ESM 导出**：`module.syncBuiltinESMExports()` 更新所有内置 ES 模块的实时绑定，以匹配 CommonJS 导出的属性。
- 💾 **模块编译缓存**：通过 `module.enableCompileCache([options])` 或环境变量启用磁盘缓存，加速后续模块加载，支持便携模式。
- 🪝 **定制钩子**：支持同步和异步钩子，用于自定义模块解析（`resolve`）和加载（`load`）逻辑，链式调用遵循 LIFO 顺序。
- 🗺️ **源映射支持**：提供 `module.SourceMap` 类及相关方法（如 `findSourceMap`、`setSourceMapsSupport`），用于处理 Source Map 以增强调试体验。
- 📚 **示例应用**：文档包含从 HTTPS 导入、代码转译（如 CoffeeScript）、导入映射等实际用例，展示钩子的强大灵活性。

### [[RFC] 由 captbaritone 提出的 useStore/createStore API · Pull Request #35449 · facebook/react · GitHub](https://github.com/facebook/react/pull/35449)

React 仓库中有一个关于新 API `useStore` 和 `createStore` 的 RFC（征求意见稿），旨在让 React 组件能够高效、正确地观察和响应非 React 状态，同时支持 React 的过渡语义，避免不必要的重新渲染。

- 🚀 **提案核心**：引入 `ReactExternalDataSource` 接口及配套的 `useStore` 和 `createStore` API，使外部状态库能与 React 的并发特性兼容。
- ⚙️ **API 设计**：`useStore` 类似 `useContext` 但支持选择器以优化渲染；`createStore` 类似 `useState`/`useReducer`，提供简单的内置状态管理。
- 🔧 **实现挑战**：需解决在过渡期间同步挂载组件、更新顺序语义等问题，当前方案通过引用计数和复用 `updateReducerImpl` 逻辑实现。
- ⚖️ **现有方案局限**：`useContext` 性能差，`useSyncExternalStore` 不支持过渡，自定义 `useEffect` 订阅难以完全符合 React 语义。
- 🚧 **待解决问题**：包括边缘情况下的生命周期管理、支持自定义相等性比较函数，以及彻底避免不必要的重新渲染。

### [现代客户端路由：导航 API  |  Web 平台  |  Chrome 开发者](https://developer.chrome.com/docs/web-platform/navigation-api/)

Navigation API 是一个全新的客户端路由标准，旨在彻底改革单页面应用（SPA）的构建方式，通过集中处理所有类型的导航事件，提供更强大、更一致的路由管理能力。

- 🚀 **核心功能**：提供全局的 `navigate` 事件监听器，统一处理链接点击、表单提交、前进/后退及程序化导航等所有导航行为。
- 🛠️ **事件处理**：通过 `NavigateEvent` 对象获取导航信息（如目标 URL、表单数据等），并可使用 `intercept()` 拦截处理或 `preventDefault()` 取消导航。
- ⚡ **异步支持**：拦截处理器支持异步操作，并可利用 `AbortSignal` 在导航被中断时取消网络请求等任务。
- 📜 **历史记录管理**：提供 `navigation.entries()` 访问完整导航历史，支持通过 `key` 直接跳转到特定历史条目，并允许开发者存储和更新状态（state）。
- 🔄 **滚动与焦点控制**：自动处理滚动恢复，也可手动调用 `scroll()` 或通过选项禁用；支持焦点重置到 `autofocus` 元素。
- 📊 **状态反馈**：通过 `navigatesuccess` 和 `navigateerror` 事件集中处理导航成功或失败的情况，便于更新 UI 或显示错误信息。
- 🧩 **兼容性与改进**：虽不触发初始页面加载的 `navigate` 事件，但完全支持传统 History API 的方法，并解决了其多框架混淆等历史问题。

### [Electron 40.0.0 | Electron](https://www.electronjs.org/blog/electron-40-0)

Electron 40.0.0 已发布，包含 Chromium、V8 和 Node.js 的版本升级，引入了多项新功能与改进，同时包含一些破坏性变更。

- 🚀 升级核心组件：Chromium 至 144.0.7559.60，Node.js 至 v24.11.1，V8 至 14.4
- ✨ 新增功能：包括内存回收原因标识、HDR 色彩空间支持、硬件加速检测、自定义协议处理选项等
- 🔧 改进特性：增强无障碍支持管理、外部共享纹理导入、系统强调色获取、文件系统 API 状态持久化等
- ⚠️ 破坏性变更：渲染进程中剪贴板 API 已弃用，macOS dSYM 文件改用 tar.xz 压缩，Electron 37.x.y 停止支持
- 📅 后续计划：团队将继续跟进 Chromium、Node 和 V8 的主要组件开发，维护项目时间线

### [jQuery 4.0.0 | 官方 jQuery 博客](https://blog.jquery.com/2026/01/17/jquery-4-0-0/)

jQuery 团队在 2026 年 1 月 17 日发布了 jQuery 4.0.0 正式版，这是近 10 年来的首个主要版本更新。该版本包含多项现代化改进和破坏性变更，建议升级前详细阅读升级指南。大多数用户只需少量代码调整即可完成升级。

- 🎉 **发布里程碑**：jQuery 4.0.0 是 20 周年纪念版，距离上一个主要版本发布已近 10 年。
- 🗑️ **移除旧版支持**：放弃对 IE 10 及更旧版本、Edge Legacy、旧版 iOS/Android/Firefox 等浏览器的支持。
- 🔒 **安全增强**：新增对 Trusted Types 的支持，优化 AJAX 请求以避免 CSP 错误。
- 📦 **源码现代化**：源码从 AMD 迁移至 ES 模块，兼容现代构建工具和浏览器原生模块。
- 🧹 **清理废弃 API**：移除多个已废弃的辅助函数（如 `jQuery.isArray`、`jQuery.trim`），推荐使用原生等效方法。
- 🧩 **精简内部方法**：从 jQuery 原型中移除仅供内部使用的数组方法（`push`、`sort`、`splice`）。
- 👁️ **事件顺序标准化**：焦点事件顺序现在遵循 W3C 规范，不再覆盖浏览器原生行为。
- 🏗️ **更小的 Slim 构建**：移除了 Deferreds 和 Callbacks 模块，体积进一步缩小（gzip 后约 19.5KB）。
- 📥 **获取方式**：可通过 jQuery CDN、npm（`npm install jquery@4.0.0`）获取，同时提供标准版和 Slim 版。

## 设计

### [重新思考“像素完美”网页设计——Smashing Magazine](https://www.smashingmagazine.com/2026/01/rethinking-pixel-perfect-web-design/)

本文批判了网页设计中“像素完美”这一过时理念，认为它在多设备、动态内容与可访问性需求并存的现代网页环境中已变得模糊、低效且有害。文章主张摒弃对静态设计图的像素级复现，转而追求以设计意图为核心，通过设计系统、响应式工具和清晰协作来构建灵活、健壮且包容的用户界面。

- 🖨️“像素完美”概念源于印刷设计，其追求固定布局的思维已不适应现代网页的流动性与多样性本质。
- 🔍 该术语定义模糊，缺乏具体技术要求，常掩盖了实际的设计与开发需求。
- 📱 当今设备种类繁多（如折叠屏、空间界面），屏幕尺寸、像素密度各异，使得单一“完美”布局无法实现。
- 🌍 动态内容（如多语言文本）会破坏基于固定内容的“完美”设计，凸显了灵活布局的重要性。
- ♿ 真正的完美应优先考虑可访问性，确保所有用户（如使用大字体或高对比度模式）都能获得良好体验。
- 🧩 现代开发基于组件化设计系统，而非单个页面，追求像素匹配会破坏系统的可复用性与一致性。
- 💸 执着于像素完美会导致技术债，如使用“魔术数字”等临时方案，使代码脆弱且难以维护。
- 🧭 解决方案是从“像素”转向“设计意图”，利用相对单位、CSS 容器查询等工具实现逻辑一致的自适应设计。
- 🏷️ 采用设计令牌（如 `--spacing-large`）而非固定数值，能在设计与代码间建立逻辑桥梁，确保系统一致性。
- 🤝 应淘汰传统的“设计交付”模式，转向基于活设计系统的协作，共同定义组件行为与响应规则。
- 💬 使用更精确的沟通语言（如“视觉一致”、“保持比例逻辑”）替代“像素完美”，能减少摩擦，提升团队协作效率。
- 🚀 作者呼吁设计师提供规则而非固定尺寸，开发者则聚焦实现设计逻辑，共同拥抱网页的流动本质，以意图驱动构建面向未来的界面。

## AI

### [Tab, Tab, Dead](https://ampcode.com/news/tab-tab-dead)

本文宣布 Amp Tab 将被逐步淘汰，原因是 AI 代码生成已从辅助工具转变为开发主体。公司指出，当前 90% 的代码由 Amp 自动生成，开发瓶颈已从“编写速度”转向“产出效率”，标志着“后智能体时代”的到来。未来将聚焦于新一代技术探索，并推荐了替代工具。

- 🚀 **AI 主导编码**：Amp 现已自动生成 90% 的交付代码，人类手动编写比例大幅下降。
- 🌅 **时代转变**：开发瓶颈从“代码编写速度”转为“代码产出速度”，部分用户无需打开编辑器即可交付代码。
- 🔚 **标签补时终结**：基于人类为主、AI 为辅的补全引擎（如 Amp Tab）已不适应新时代，将被淘汰。
- 🎯 **聚焦未来**：团队将资源转向“后智能体时代”的技术探索，而非维护旧工具。
- ⏳ **过渡安排**：Amp Tab 将持续支持至 2026 年 1 月底，后续推荐使用 Cursor、Copilot 或 Zed 等工具。
- 😌 **团队感言**：联合创始人 Quinn 对此表示怀念，但认同变革必要性。

### [social-media-agent](https://github.com/langchain-ai/social-media-agent)

这是一个名为“社交媒体代理”的开源项目，它能够根据提供的 URL 内容自动生成 Twitter 和 LinkedIn 帖子。项目采用人机协同（HITL）流程处理社交媒体平台的身份验证，并允许用户修改、接受或拒绝生成的帖子。支持快速启动和高级配置两种模式，可集成多种外部服务（如 Arcade、Supabase、Slack 等），并提供了自定义提示词和帖子风格的灵活选项。

- 🚀 **快速启动模式**：通过基础配置快速运行代理，但缺少部分高级功能（如 GitHub/Twitter/YouTube 内容解析、Slack 集成和图片上传）。
- 🔑 **环境变量配置**：需设置 Anthropic API、LangSmith、FireCrawl 和 Arcade 等服务的密钥，以支持 LLM 生成、网络爬取和社交平台认证。
- 🔐 **身份验证方式**：支持使用 Arcade（快速设置）或自建 Twitter/LinkedIn 开发者账户进行授权，后者需配置 OAuth 回调和服务端。
- 🗃️ **数据存储与集成**：高级模式需配置 Supabase 存储图片、Slack 接收消息、GitHub API 读取仓库内容，以实现完整功能。
- 🤖 **代理运行与监控**：通过 LangGraph CLI 启动本地服务器，使用内置脚本生成帖子，并可通过 Agent Inbox 界面管理中断事件和帖子审批。
- ⚙️ **自定义与扩展**：允许修改提示词（如业务背景、帖子结构、示例推文）和内容规则，以适配不同行业或内容风格的需求。

## 其他

### [译：如何在一天内彻底改变你的生活](https://sorrycc.com/how-to-completely-change-your-life-in-a-day)

本文批判了传统“新年愿望”的肤浅性，指出大多数人改变失败是因为方法错误。作者提出，真正的改变源于身份与目标的深层转变，而非表面自律。文章通过七个部分，系统阐述了从心理学、行为学到实践层面的改变框架，旨在引导读者通过自我剖析、目标重构和持续行动，在一年内实现深刻而持久的生活转变。

- 🎯 **摒弃肤浅愿望**：传统新年愿望常因盲从和追求表面意义而失败，真正的改变需要更深刻的自我重塑。
- 🏗️ **身份先于行动**：达成目标的关键是首先成为“能实现目标的人”，让正确行为自然发生，而非强迫自律。
- 🧠 **行为由潜意识目标驱动**：拖延等行为常是潜意识为逃避评判等目标服务，改变需重新编程心智目标。
- 🛡️ **身份防御阻碍成长**：人对自我认同有强烈保护欲，当身份受挑战时会触发抗拒，从而阻碍向新阶段进化。
- 📈 **意识层次决定生活状态**：心智按可预测阶段进化，从冲动、从众到战略、统一，想要的生活存在于更高意识层面。
- 🧭 **智力是获取所求的能力**：高智力体现为在“设定目标 - 行动 - 反馈”的循环中持续迭代、坚持并洞察全局。
- ⚡ **用“一日协议”启动改变**：通过挖掘不满、构建“反向愿景”与“愿景 MVP”、中断自动驾驶模式，可在一天内为全新生活奠基。
- 🎮 **将生活游戏化以保持动力**：把愿景化为游戏任务、Boss 战与日常，能构建抵御干扰的“力场”，使改变过程可持续。

---

我从未见过哪个群体比程序员更热衷于分享知识。其他行业都是严守知识、保守秘密，程序员则是免费提供源代码、书籍、博客文章、演示文稿、视频教程等等。

编程领域没有什么神圣不可侵犯的东西。如果你想学习，你可以找到免费书籍、完整的源代码、论坛、聊天室、邮件列表、线下聚会、博客文章、视频讲座、教程以及你可能需要的一切资源。尽管举手，总会有人乐于助人，倾囊相授。

-- 《我是如何学习所有编程知识的》

---

如果你想批评大型组织的运作方式，首先要了解它们为何如此运作。否则，批评会显得尖锐，但却毫无意义。

-- 《关于大型软件公司的常见误解》
