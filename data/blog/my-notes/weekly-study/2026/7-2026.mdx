---
title: 2026-第七周
date: '2026-02-16'
tags: ['WEEKLY-2026']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [完美代码审查：如何在提升质量的同时减轻认知负担——丹尼尔·巴斯特里奇](https://bastrich.tech/perfect-code-review/)

本文概述了构建高效代码审查流程的 PERFECT 原则，旨在降低认知负荷并提升代码质量。通过明确审查目的、处理边界情况、确保可靠性、遵循设计形式、验证测试证据、提升代码清晰度及管理主观偏好，使审查过程结构化、清晰且一致。

- 🎯 **目的**：代码必须解决既定任务，这是首要且不可妥协的要求。审查者需先理解任务目标，再验证代码实现是否符合预期。
- 🚧 **边界情况**：识别并处理业务与技术上的边界情况，如异常输入、边界值、空值等，能显著减少生产环境中的错误。
- 🔒 **可靠性**：确保代码无性能与安全问题，避免引入明显瓶颈或安全漏洞，这对商业或关键项目尤为重要。
- 🏗️ **形式**：代码应符合设计原则（如高内聚低耦合），提升可读性与可维护性，减少长期维护成本。
- ✅ **证据**：测试与持续集成流程必须通过，确保代码处于可部署状态，测试覆盖应遵循约定且避免仅为测试而写的特殊逻辑。
- 📖 **清晰度**：代码应清晰传达意图，通过命名、结构等约定提升可读性，便于他人理解与维护。
- 👅 **品味**：个人偏好不应阻碍变更，缺乏依据的主观意见可被忽略，但有价值的建议可转化为团队共识。

### [在 DevTools 中查找 JavaScript 中特定对象的分配位置](https://heikkila.dev/blog/find-where-a-specific-object-was-allocated-in-javascript/)

本文介绍了一种在 Chrome DevTools 内存分析器中追踪特定对象创建位置的方法，适用于调试时因对象被回收或难以筛选而无法定位来源的情况。

- 🐛 **调试痛点**：在调试网络请求或大型代码库时，常因调用栈被隐藏或对象被回收而难以定位特定对象的创建位置。
- 📊 **内存分析器限制**：Chrome DevTools 的“时间轴上的分配”功能可显示对象分配位置，但对象可能已被清理，且筛选条件（如分配时间、构造函数名）往往不够精确。
- 💡 **核心技巧**：通过**故意泄露对象**使其在内存分析中可见。具体步骤包括：开启分配堆栈跟踪、在调试器中暂停并将对象保存为全局变量、在控制台创建具有独特类名的新对象来引用目标值。
- 🔍 **筛选定位**：停止分析后，在内存分析器中按类名（如 `AAAAAAAA`）筛选，即可找到目标对象及其完整的创建堆栈跟踪。

## 工具

### [cc-wf-studio](https://github.com/breaking-brake/cc-wf-studio)

CC Workflow Studio 是一款可视化 AI 工作流编辑器，支持通过拖拽或自然语言对话设计复杂的 AI 代理工作流。它可一键导出至多种 AI 代码工具（如 Claude Code、GitHub Copilot 等），并直接运行工作流，无需编写代码。

- 🎨 **可视化编辑** – 通过直观的拖放画布设计 AI 工作流，无需编码
- 💬 **AI 对话编辑** – 用自然语言与 AI 交互，迭代改进工作流逻辑与功能
- ⚡ **一键导出与运行** – 支持将工作流导出为 .claude、.github/prompts/ 等格式，并直接从编辑器运行
- 🤖 **多平台集成** – 兼容 GitHub Copilot、OpenAI Codex、Roo Code 等 AI 开发工具（部分为实验性功能）
- 🔄 **MCP 服务器支持** – 通过内置 MCP 服务器实现与 AI 代理的无缝通信，自动同步工作流更新

### [playwright-cli](https://github.com/microsoft/playwright-cli)

本文介绍了 Playwright CLI 工具，它是一个专为现代编码智能体（如 Claude Code、GitHub Copilot 等）设计的命令行界面。该工具通过提供一系列简洁、高效的命令来实现浏览器自动化，其核心优势在于令牌使用效率高，避免了向大语言模型上下文加载大量工具架构和页面可访问性树，从而更适合处理大型代码库、测试和复杂推理任务。文章详细说明了其安装、核心功能、会话管理、监控以及丰富的配置选项。

- 🚀 **核心定位**：Playwright CLI 是一个为编码智能体优化的命令行工具，通过 SKILLs 提供令牌高效的浏览器自动化，相比 MCP 更适合高吞吐量的编码工作流。
- ⚙️ **安装与启动**：通过 npm 全局安装，使用 `playwright-cli --help` 查看命令，并可选择为智能体安装 SKILLs 或让其直接读取 CLI 帮助信息进行操作。
- 🖥️ **核心操作**：提供打开页面、导航、点击、输入、截图等丰富的浏览器控制命令，支持有头和无头模式，并默认在内存中保持会话状态。
- 🔧 **会话管理**：支持创建和管理多个独立的浏览器会话，可通过 `-s=` 参数指定会话，并支持将会话数据持久化到磁盘。
- 📊 **监控与调试**：提供 `playwright-cli show` 命令打开可视化仪表板，实时查看和控制所有运行中的浏览器会话，便于观察和干预自动化过程。
- ⚡ **高效特性**：设计上注重令牌效率，不强制将页面数据推入 LLM 上下文，通过简洁的命令和快照机制为智能体提供必要的页面状态信息。
- 📁 **配置灵活**：支持通过 JSON 配置文件或大量环境变量对浏览器类型、超时、网络拦截、控制台输出、视频录制等进行深度定制。
- 🛠️ **功能全面**：涵盖网络请求模拟、存储状态管理（Cookie、LocalStorage）、标签页操作、DevTools 集成、代码片段执行以及测试生成和追踪录制等高级功能。

### [prek](https://github.com/j178/prek)

prek 是一个用 Rust 重写的 pre-commit 替代工具，旨在提供更快的速度、零依赖的单二进制体验，并完全兼容原有的 pre-commit 配置。它通过并行化处理、共享工具链和集成 uv 等优化，显著提升了钩子运行效率，并支持单仓库多项目配置。目前已被 CPython、Apache Airflow 等知名项目采用。

- 🚀 **性能优化** – 比 pre-commit 更快，占用磁盘空间更少，支持并行克隆仓库和运行钩子。
- 📦 **零依赖便携** – 仅需单个二进制文件，无需安装 Python 或其他运行时环境。
- 🔧 **完全兼容** – 支持原有 pre-commit 的配置文件与钩子，可无缝迁移。
- 🏗️ **内置增强功能** – 支持单仓库多项目工作区、自动管理 Python 版本与虚拟环境，并提供 Rust 原生内置钩子。
- ⚙️ **智能工具链** – 使用 uv 管理 Python 依赖，共享 Node.js、Go 等语言工具链，减少重复安装。
- 🌍 **广泛采用** – 已被 FastAPI、Ruff、Home Assistant 等众多开源项目使用或推荐。

## 更新

## 设计

## AI

## 其他

### [理念重于实施](https://boz.com/articles/ideas-implementation)

不要执着于已构建的方案，而应专注于追求的目标。将重心放在目标而非具体实施方式上，才能在现实变化时灵活调整方向。早期决策往往信息不足，若将其视为不可更改，只会增加修正成本。沉没成本不可避免，但固执己见是可以避免的。

- 🎯 锚定目标而非方法：关注核心目的，为调整留出空间
- 🔄 保持灵活修正能力：早期决策不必神圣化，应随认知更新而优化
- 💡 轻握方案重持目标：避免对工具或架构过度执着，聚焦问题本质
- 🧠 在行动中深化理解：通过实践迭代完善方案，拒绝前期完美主义
