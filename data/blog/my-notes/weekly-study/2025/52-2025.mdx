---
title: 2025-第五十二周
date: '2025-12-11'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [React 编译器的静默故障（及其修复方法）](https://acusti.ca/blog/2025/12/16/react-compiler-silent-failures-and-how-to-fix-them/)

本文讨论了作者从长期依赖手动记忆化（如 useMemo 和 useCallback）转向依赖 React Compiler 的经历，并强调了在编译器静默失败时如何通过 ESLint 规则确保关键组件的性能优化。

- 🧠 React Compiler 消除了手动记忆化的认知负担，让开发者能更专注于产品逻辑而非性能优化细节。
- ⚠️ 编译器在无法优化组件时会静默失败，回退到标准 React 行为，这可能影响高性能交互场景的用户体验。
- 🔍 通过启用未文档化的 ESLint 规则 `react-hooks/todo`，可以在编译失败时中断构建，从而及时发现并处理问题。
- 🚧 当前编译器暂不支持某些模式，如在 try/catch 中使用条件语句、解构后修改 props 等，需通过重构或禁用规则来应对。
- 🛠️ 建议对关键路径组件强制启用编译检查，对非关键组件则可灵活禁用规则，以平衡性能与代码清晰度。
- ✅ 尽管存在临时限制，React Compiler 仍能显著提升开发体验，尤其适合构建高性能交互式界面。

### [为什么我的视图过渡会闪烁？](https://piccalil.li/blog/why-are-my-view-transitions-blinking/)

视图过渡（View Transitions）API 能通过浏览器自动处理快照和动画，实现流畅的页面状态切换，但使用不当会导致恼人的“闪烁”问题。核心在于浏览器需通过 `view-transition-name` 正确关联新旧状态中的元素，否则会回退到生硬的交叉淡入淡出效果。

- 🚨 **常见闪烁原因**：元素关联失败，通常由于旧元素未设置过渡名称、名称重复、仅用 CSS 隐藏而非移除 DOM 元素，或名称设置时机错误导致。
- 💡 **关键解决模式**：通过真正的 DOM 操作（移除旧元素、创建新元素）而非仅切换可见性，并为新旧元素动态分配相同的 `view-transition-name`。
- 🛠️ **动态命名策略**：对条件性出现/消失的元素，在过渡前通过 JavaScript 动态设置名称，并在过渡完成后及时清理，以避免名称冲突。
- 📝 **实施检查清单**：过渡前为旧元素分配唯一名称；过渡中执行最小 DOM 操作并为新元素分配相同名称；过渡后清理名称并确保可访问性。
- ⚠️ **静默错误与陷阱**：注意重复的名称、时机问题、未清理的残留名称、CSS 特异性冲突及浏览器兼容性，这些都会导致过渡失败而不报错。
- 🔧 **通用原则**：确保每个过渡名称在页面中同一时刻唯一，优先使用 DOM 增删而非视觉隐藏，并分离不同组件的动画名称以实现独立过渡。

### [在 Blender 中使用 React 驱动 3D 场景](https://romanliutikov.com/blog/driving-3d-scenes-in-blender-with-react)

本文介绍了一个探索性项目，它通过在 Blender 中嵌入 JavaScript 引擎并实现自定义 React 协调器，使开发者能够使用 React 的声明式方法来创建和管理 Blender 中的 3D 场景。

- 🧩 **架构设计**：在基于 Python 的 Blender 中，通过 Python 插件嵌入 QuickJS JavaScript 引擎，并将 Blender API 暴露给 JavaScript，从而允许 React 代码调用 Blender 命令。
- ⚙️ **自定义协调器**：实现了一个 React 协调器，将 React 的创建、更新和删除操作转换为发送给 Python 的命令，进而调用 Blender 原生 API 来操作 3D 对象。
- 🧱 **组件化场景定义**：开发者可以使用熟悉的 React 组件模式来定义 Blender 场景，例如使用`:cube`、`:sphere`等关键字创建基本几何体，并支持实时热重载。
- 🎨 **材质作为子元素**：材质可以作为网格对象的子组件进行声明式定义，协调器会自动处理材质的分配与绑定。
- 🌀 **Hook 驱动动画**：利用 React Hooks（如自定义的`use-frame`钩子）实现逐帧动画更新，状态变化会触发 Blender 对象属性的实时同步。
- 🔗 **几何节点组件化**：将 Blender 强大的几何节点系统封装为 React 组件，支持通过组合式声明创建复杂的程序化几何结构。
- 🌳 **自然的层级关系**：React 组件树直接映射到 Blender 对象的父子层级，协调器会自动处理对象间的依附关系，保持场景结构的一致性。

### [AI 编码代理如何在我们应用中埋下定时炸弹](https://acusti.ca/blog/2025/12/09/how-ai-coding-agents-hid-a-timebomb-in-our-app/)

文章概述了开发者在使用 AI 编程助手重构代码时，因一条关键注释被删除，导致`readOnly`属性被移除，从而引发无限递归渲染的严重 Bug。该 Bug 被 React 19 的`<Activity>`组件暂时掩盖，最终导致浏览器内存耗尽而崩溃。文章通过这一事件，强调了在 AI 辅助编程时代，仅靠注释和代码审查已不足以保证代码安全，必须通过编写测试来强制约束关键逻辑。

- 🐛 **Bug 根源**：AI 助手在重构时删除了警告“禁用编辑 UI 以防止无限递归”的注释，随后在另一项改动中移除了确保安全的`readOnly`属性，导致组件预览陷入无限递归。
- 🕵️ **隐蔽的崩溃**：React 19 的`<Activity>`组件以低优先级在后台渲染隐藏 UI，掩盖了无限递归的即时崩溃，使 Bug 在用户使用几分钟后才因内存耗尽而暴露。
- 🔍 **曲折的调试**：崩溃堆栈深达万层且匿名，最初被误判为动画库 Motion 的问题，最终通过移除`<Activity>`包装并追溯代码提交历史，才定位到被删除的`readOnly`属性。
- 📝 **注释的局限性**：在 AI 频繁重构的代码库中，仅靠注释无法保障关键约束的持久性；被删除的注释使 AI 失去了理解属性重要性的上下文。
- ✅ **测试即约束**：作者反思应编写测试（如验证所有预览组件是否强制设置`readOnly=true`），而非仅依赖注释，以主动防御此类结构性错误。
- 🤖 **AI 协作新范式**：在 AI 辅助开发中，必须将重要逻辑假设（如递归边界）编码为自动化测试，而非仅停留在文档层面，以提升代码的健壮性。

### [CSS 文本框修剪 | 博客 | Chrome 开发者](https://developer.chrome.com/blog/css-text-box-trim)

CSS text-box-trim 属性允许开发者精确控制文本上方和下方的空间，解决了字体排版中因“半行距”导致的布局对齐难题。

- 🎨 **控制文本间距**：通过 `text-box` 属性可修剪文本块顶部和底部的多余空间，实现更精准的视觉对齐。
- 🔧 **简化居中与对齐**：消除半行距影响后，元素内边距设置更直观，便于实现光学居中及与其他元素的对齐。
- 📐 **适应多种字体**：无论字体家族如何变化，该属性都能一致地调整文本框空间，提升跨平台排版一致性。
- 🧩 **灵活语法选项**：支持 `trim-start`、`trim-end`、`trim-both` 等值，并可结合 `cap`、`ex` 等参数微调修剪基准。
- 🌐 **广泛适用场景**：适用于按钮、标签、标题等元素，改善多行文本、响应式布局及不同书写模式的排版效果。

### [野生环境下的高级 React 应用](https://largeapps.dev/case-studies/advanced/)

本文通过多个真实案例研究，总结了 2022 至 2025 年间 React 和 Next.js 在大型 Web 应用中的高级实践与最佳方案。这些案例展示了团队如何通过性能优化、渲染策略调整、缓存管理、状态管理简化以及开发者体验改进，显著提升核心 Web 指标、用户体验和业务成果。关键趋势包括：性能优化成为重中之重，尤其是针对 LCP 和 INP 的改进；SSR 与 CSR 的混合使用成为主流；多层缓存策略广泛应用；状态管理趋向轻量与专用化；开发者体验通过框架约定和工具优化得到提升；可访问性被纳入设计核心；最终所有技术努力都服务于打造更快、更流畅、更具包容性的用户体验。

- 🚀 **性能优化至关重要**：各团队通过优化核心 Web 指标（如 LCP 和 INP）、减少 JavaScript 负载、拆分长任务以及利用 React 18 的并发特性（如 Transitions 和 Suspense），显著提升了页面加载速度和交互响应性，并带来了 SEO 排名和业务转化的提升。
- ⚖️ **SSR 与 CSR 的平衡艺术**：案例表明，没有单一的渲染模式适合所有场景。最佳实践是混合使用服务器端渲染（SSR）以实现快速初始加载和 SEO，结合客户端渲染（CSR）来提供丰富的交互体验。渐进式水合和“岛屿架构”思想有助于减少不必要的客户端工作。
- 💾 **智能缓存策略**：在 CDN、应用层和客户端实施多层缓存是提升速度的关键。团队利用 Next.js 的增量静态再生（ISR）、数据缓存以及客户端状态库（如 React Query）来加速内容交付、减少重复请求，并谨慎处理数据新鲜度问题。
- 🧩 **简化的状态管理**：趋势是避免过度工程化的全局状态，转而使用 React Context、useState 等内置工具，或采用轻量级专用库（如 Zustand、Jotai）处理客户端状态，并用 React Query 管理服务器状态。这降低了复杂性和包体积。
- 🛠️ **改善开发者体验与可维护性**：Next.js 的约定式文件结构（如 App Router）、更快的构建工具（如 Turbopack）、以及 Suspense、Error Boundaries 等 React 原语的使用，提升了开发效率、代码清晰度和项目可维护性。
- ♿ **可访问性内置设计**：可访问性已成为高质量应用的标准要求。最佳实践包括使用语义化 HTML、正确 ARIA 属性、确保键盘导航、进行辅助技术测试，并在设计阶段就予以考虑，这不仅能服务残障用户，也往往能提升整体 UX 和 SEO。
- 😊 **用户体验提升与影响**：所有技术优化的最终目标是卓越的用户体验。更快的加载、无缝的导航过渡、跨设备的一致性以及可靠的错误处理，直接带来了更高的用户满意度、参与度和业务转化率，证明了性能投资的实际价值。

### [2025 年 React 发展趋势](https://www.robinwieruch.de/react-trends/)

2025 年 React 生态系统将迎来重大变革，核心趋势围绕服务器驱动开发、全栈能力扩展及工具链革新展开，旨在提升性能、开发体验与应用架构的现代化。

- 🚀 **React 服务器组件（RSC）成为标准**：经过 Next.js 等框架的推动，RSC 将在 2025 年普及为 React 生态的基础原语，允许组件在服务器端执行，减少客户端 JavaScript 体积并直接访问后端资源。
- 🔄 **React 服务器函数（RSF）统一数据操作**：作为 React 服务器动作（RSA）的演进，RSF 将数据获取和变更整合为统一 API，简化客户端与服务器端的数据交互，预计被主流框架广泛支持。
- 📝 **React 19 增强表单处理**：新增`action`属性及`useFormStatus`等钩子，使表单提交与状态管理更高效，同时保持与第三方库（如 React Hook Form）的兼容性。
- 🏗️ **框架选择更加关键**：Next.js、TanStack Start 和 React Router 等框架竞争加剧，开发者需根据项目需求权衡 RSC/RSF 支持、路由策略和渲染模式。
- 🌐 **React 向全栈框架演进**：借助 RSC 和 RSF，React 能够更紧密集成后端服务（如数据库、身份验证），推动构建端到端的全栈应用。
- 🎨 **UI 设计趋向“Shadcn 化”**：Shadcn UI 成为 React 项目样式标准，提供可定制组件，但未来可能出现新方案以突破同质化设计。
- 🤖 **AI 与 React 深度融合**：React 代码广泛用于 AI 模型训练，同时其全栈特性使其成为开发 AI 应用（如结合 Vercel AI SDK）的理想选择。
- ⚡ **工具链优化（Biome）兴起**：Biome 作为 ESLint 和 Prettier 的替代方案，以 Rust 构建的高性能格式化与检查工具，有望简化开发配置。
- ⚙️ **React 编译器进入实践**：自动处理`useCallback`和`memo`等性能优化，减少手动记忆化需求，目前处于测试阶段。
- 📂 **组件命名规范更受重视**：社区将推动更清晰的文件命名约定，以提升项目可维护性。

### [利用弱引用颠覆控制](https://jlongster.com/subverting-control-weak-refs)

弱引用是一种强大的语言特性，它允许在不阻止垃圾回收的情况下引用对象，从而避免内存泄漏，并支持创建灵活的缓存和状态管理方案。

- 🧠 **弱引用的定义与作用**：弱引用不会阻止对象被垃圾回收，与强引用不同，它允许对象在不再被需要时被清理，从而避免内存泄漏。
- 🛠️ **JavaScript 中的弱引用 API**：主要包括`WeakMap`和`WeakRef`，其中`WeakMap`对键保持弱引用，而值保持强引用，常用于缓存场景。
- 💾 **WeakMap 的缓存应用**：通过`WeakMap`可以实现基于对象的缓存，例如缓存函数结果，当对象被垃圾回收时，缓存条目自动移除，无需手动管理内存。
- 🔄 **绕过抽象控制的技巧**：弱引用可用于在无法修改现有类或依赖网络层的情况下，添加缓存或状态管理功能，例如通过`WeakMap`关联额外数据到对象。
- 🧩 **扩展对象功能的模式**：使用`WeakMap`可以模拟“扩展”类，为现有对象添加新功能，而无需修改原始类或担心命名冲突。
- ⚠️ **使用注意事项**：弱引用应谨慎使用，尤其是在直接使用`WeakRef`时，因为它可能导致不可预测的行为，适合作为底层工具。
- 🧰 **实际应用场景**：适用于需要临时缓存、状态跟踪或在不侵入现有代码的情况下增强对象功能的场景，提升代码的灵活性和可维护性。

### [WeakRef - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef)

WeakRef 对象允许持有对另一个对象的弱引用，不会阻止该对象被垃圾回收机制回收，但需谨慎使用以避免依赖垃圾回收的具体行为。

- 🎯 WeakRef 持有对目标对象的弱引用，不会阻止垃圾回收器回收该对象
- ⚠️ 应尽量避免使用，因为垃圾回收行为因引擎和版本而异，不可预测
- 🔄 多个 WeakRef 指向同一目标时行为一致，deref() 结果相同
- 🛠️ 构造函数 WeakRef() 创建实例，实例方法 deref() 返回目标对象或 undefined
- 📝 可用于监测 DOM 元素是否存在，并在元素被移除时停止相关操作

### [Tailwind CSS：定位子元素（必要时）](https://cekrem.github.io/posts/tailwind-targeting-child-elements/)

本文探讨了在无法直接控制内部元素样式的情况下，如何利用 Tailwind CSS 的任意变体语法来为子元素应用样式，并对比了传统 CSS 方法的优劣。

- 🎯 **核心问题**：Tailwind 提倡直接为元素添加工具类，但面对来自 CMS 或第三方的不受控 HTML 内容时，需要为子元素（如链接、列表）设置样式。
- 🛠️ **传统方案**：为容器编写独立的 CSS 样式表（如 `.cms-content a { ... }`）是简单且可维护的推荐做法。
- ⚙️ **Tailwind 方案**：使用任意变体语法（如 `[&_a]:font-semibold`），通过 `&` 代表当前元素，后接 CSS 选择器来定位子元素。
- 📖 **语法解析**：`&` 在 Tailwind 中代表当前元素的生成类，`_` 代表空格（后代选择器），`>` 代表直接子元素。
- 🔧 **常见模式**：支持直接子元素（`[&>div]`）、所有后代（`[&_a]`）及子元素伪状态（`[&_a:hover]`）等选择器。
- ⚖️ **适用场景**：适用于希望完全使用工具类、避免切换至 CSS 文件，或仅需少量样式规则的情况。
- 📝 **实践示例**：展示了为 CMS 文章内容容器添加链接、图片、列表样式的 React 与 Elm 代码示例。
- ✅ **最终建议**：对于嵌入式内容，独立的 CSS 样式表通常更清晰易维护；但若坚持使用 Tailwind 工具类，任意变体提供了可行的解决方案。

## 工具

### [esmx](https://github.com/esmnext/esmx)

这是一个名为 Esmx 的下一代微前端框架的 GitHub 项目主页介绍。该框架基于原生 ESM 和 ImportMap 构建，主打零运行时开销、无沙箱的多框架混合开发，并提供了高性能的构建工具和完整的 SSR 支持。

- 🚀 **核心特性**：基于原生 ESM + ImportMap，实现零运行时开销、无沙箱；采用 Rspack 提供高性能构建；支持完整的 SSR；使用标准语法，学习成本低；兼容 Vue、React 等多种前端框架。
- 📊 **对比优势**：与传统微前端方案相比，Esmx 采用原生 ESM 架构而非手动沙箱/代理，实现了真正的零运行时开销，并使用标准语法而非特定框架 API。
- 🛠️ **快速开始**：可通过命令 `npx create-esmx@latest my-app` 快速创建新项目。
- 📦 **核心包**：项目包含多个核心 NPM 包，如 `@esmx/core`（框架核心）、`@esmx/router`（路由）、`@esmx/rspack`（构建工具）等，目前均处于预览状态。
- 🎯 **示例项目**：提供了多个技术栈的演示项目，包括原生 HTML、Vue 2.7、Preact 等，并附有在线预览链接。
- 💡 **开发说明**：开发时需要先运行 `pnpm build` 构建所有包和示例，然后进入具体项目目录进行开发。

### [rscexplorer](https://github.com/gaearon/rscexplorer)

本文介绍了 RSC Explorer，这是一个用于在浏览器中运行和调试 React Server Components (RSC) 协议的教育工具。它允许用户逐步检查 RSC 流、观察 React 树的实时变化，并包含多个示例以展示服务器与客户端功能的交互。该项目为开源工具，采用 MIT 许可证，强调对真实 RSC 环境的模拟，且不依赖 React 内部实现。

- 🔧 **工具用途** – RSC Explorer 是一个面向教育和实验的浏览器工具，用于探索 React Server Components 协议。
- 🌐 **运行环境** – 在浏览器中同时运行 RSC 的服务器和客户端部分，模拟真实 RSC 环境。
- 🔍 **核心功能** – 支持逐步检查 RSC 流、观察 React 树的变化，并提供多种交互示例（如计数器、表单操作等）。
- 📦 **项目状态** – 开源项目，采用 MIT 许可证，目前有 235 个星标、7 个分支和 12 次提交。
- 🛠️ **开发原则** – 不依赖 React 内部实现或协议格式，仅进行端到端测试，代码结构可能存在优化空间。
- 📄 **嵌入支持** – 提供嵌入代码，可将 RSC Explorer 集成到其他页面中。

### [archestra](https://github.com/archestra-ai/archestra)

Archestra 是一个企业级 MCP 原生集中式 AI 平台，旨在简化公司内部的 AI 使用，通过提供用户友好的 MCP 工具箱、可观测性和控制功能，并建立在强大的安全基础之上。

- 👥 **平台团队**：集中管理 MCP 服务器，治理数据与凭证访问，降低数据泄露风险，并监控与优化 AI 成本。
- 👩‍💻 **开发人员**：可轻松部署全组织范围的 MCP 服务器与智能体，无需担忧底层安全问题。
- 📈 **管理层**：一键推动全组织（包括非技术人员）采用 MCP，降低高达 96% 的 AI 成本，并获得全面的使用与数据访问可见性。
- 🏢 **私有 MCP 注册中心**：支持自托管或远程、自建或第三方的 MCP，实现安全可控的团队内共享。
- ☸️ **Kubernetes 原生编排器**：在 Kubernetes 中运行并管理 MCP 服务器的状态、API 密钥和 OAuth。
- 🛡️ **安全子智能体**：采用双 LLM 架构隔离危险工具响应，防止提示词注入攻击。
- 🚫 **非概率性安全防护**：通过动态工具等技术防止模型因提示词注入导致数据外泄。
- 💰 **成本监控与动态优化**：支持按团队、智能体或组织设置成本监控与限额，并通过自动切换至更经济模型节省高达 96% 的成本。
- 📊 **全方位可观测性**：提供指标、追踪和日志，便于分析令牌使用、工具调用及性能表现。
- ⚡ **生产就绪**：具备低延迟（P95 仅 45 毫秒），提供 Terraform 模块与 Helm Chart，支持快速部署与集成。
- 🚀 **快速开始**：支持 Docker 一键部署，并提供与 LangChain、Vercel AI 等多种生态的集成指南。
- 🤝 **社区贡献**：欢迎社区贡献，提供详细的开发指南与安全漏洞赏金计划。

### [typeslayer](https://github.com/dimitropoulos/typeslayer)

TypeSlayer 是一个用于诊断和修复 TypeScript 性能问题的可视化工具，它通过本地 Web UI 提供交互式分析，帮助开发者（尤其是库作者和高级用户）大幅提升类型检查效率。

- 🚀 **快速启动**：在项目根目录运行 `npx typeslayer` 即可启动本地 Web UI，自动生成跟踪数据和 CPU 性能分析。
- 📊 **交互可视化**：提供树状图、力导向图、Speedscope/Perfetto 视图等直观工具，帮助定位性能瓶颈。
- 🎯 **目标用户**：主要面向 TypeScript 库作者、高级用户及追求极致性能优化的开发者，可帮助实现类型检查速度的显著提升（如案例中的 380,000 倍加速）。
- 🔒 **数据与安全**：目前不收集分析数据，所有数据存储在本地用户目录；工具具有与终端相同的文件读取和脚本执行权限。
- 🌐 **跨平台支持**：支持 Linux x64、macOS ARM64 和 Windows x64 系统。
- 🛠️ **技术栈**：基于 Tauri、React、Rust、TypeScript 等构建，强调可视化体验而非纯 CLI 工具。
- ❓ **未来规划**：计划添加 CI 分析支持和 monorepo 支持，未来可能增加基础使用统计。

### [MarkdownDB](https://github.com/matt-oconnell/markdowndb)

MarkdownDB 是一个 JavaScript 库，可将 Markdown 文件转换为结构化、可查询的数据库（支持 SQLite 和 JSON 格式），旨在帮助用户轻松构建功能丰富的、基于 Markdown 的网站。

- 🛠️ **核心功能**：将文件夹中的 Markdown 文件解析并索引为可查询的数据库（SQLite 或 JSON），提取 Frontmatter、标签、内部链接和任务等结构化数据。
- 🚀 **使用方式**：提供命令行工具（`npx mddb`）和 Node.js API，支持监听文件变化（`--watch` 标志）和预构建脚本集成。
- 🔍 **查询能力**：通过灵活的 API 按 URL 路径、标签、Frontmatter 字段、文件类型、扩展名和文件夹等多种条件查询文件与链接。
- ✨ **数据增强**：支持“计算字段”，允许通过自定义函数（如从标题提取内容）动态添加元数据，并可通过配置文件（`markdowndb.config.js`）包含/排除特定文件。
- ⚙️ **集成示例**：特别展示了如何在 Next.js 项目中集成，通过 `getStaticProps` 获取数据并渲染博客列表等静态页面。
- 🏗️ **项目状态**：开源（MIT 许可证），处于活跃开发中，拥有详细的路线图（如数据验证、自定义类型支持），并与 Content Collections 等相关项目进行了比较。

### [quickgpt-raycast](https://github.com/ddhjy/quickgpt-raycast)

QuickGPT for Raycast 是一款专业的提示词管理扩展，专为 Raycast 设计，支持通过 HJSON 格式和 Git 版本控制高效管理大量提示词。它提供高级占位符系统、多目录组织、临时目录、深度链接等功能，并能与 PopClip、Gemini 等工具无缝集成，提升工作流效率。

- 🚀 **专业提示词管理** – 支持 HJSON 格式和 Git 版本控制，可像管理代码一样迭代和维护 200+ 提示词。
- 📂 **灵活目录配置** – 支持主目录和最多 4 个自定义目录，可添加临时目录（自动 7 天后过期）。
- 🔧 **高级占位符系统** – 支持动态内容注入，如 `{{input}}`、`{{selection}}`、`{{file:path}}` 及回退链逻辑。
- 🔗 **深度集成能力** – 支持从任何应用通过 Raycast 调用，兼容 AppleScript 脚本，并提供剪贴板历史记录。
- 🎯 **便捷操作与搜索** – 支持拼音匹配搜索、提示词固定、输入历史（`⌘ + Y`）和剪贴板历史（`⌘ + Shift + Y`）。
- 🌐 **深度链接访问** – 可通过特定 URL 直接访问提示词，并支持通过参数传递占位符值。
- 📝 **结构化提示词格式** – 使用 HJSON 定义提示词，支持嵌套子提示词、属性继承和下拉选项。
- ⚙️ **开发者友好** – 提供完整的项目结构、测试脚本和贡献指南，采用 TypeScript 严格模式开发。

## 更新

### [Express@5.1.0：现为 npm 默认版本，附带长期支持时间线](https://expressjs.com/2025/03/31/v5-1-latest-release.html)

Express v5.0.0 已于去年 9 月发布，但直到现在才在 npm 上设为默认版本。团队在过去一年中致力于完善文档、提供迁移支持并确保生态系统兼容性，同时制定了长期支持策略，明确了版本的生命周期阶段。现在 v5.1.0 已成为 npm 上的最新版本，标志着 v5 进入活跃支持阶段，v4 则转入维护阶段。

- 📄 **文档与迁移指南更新**：团队更新了 v5 文档并提供了详细的迁移指南，帮助开发者顺利升级。
- 🔧 **自动化迁移工具**：推出了 codemod 包，自动化处理从 v4 到 v5 的代码迁移，减少手动工作量。
- 🌍 **生态系统兼容性**：考虑到 Express 庞大的生态系统和初学者用户，团队给予了足够时间让中间件和文档更新，确保平稳过渡。
- 🛡️ **长期支持策略**：引入了三个支持阶段：CURRENT（新版本发布后至少 3 个月）、ACTIVE（设为 npm 最新版本后至少 12 个月）和 MAINTENANCE（前一个主要版本进入 12 个月维护期），并提供了 v4 和 v5 的预计时间表。
- 🚀 **v5.1.0 主要更新**：包括支持 Uint8Array、更新依赖版本、添加资金字段、性能优化等，同时更新了多个依赖包。
- 👥 **社区贡献与未来计划**：感谢所有贡献者，并宣布了性能工作组、TypeScript 体验改进等计划，v6 的讨论也已开始。

### [2025 年现代 Node.js 模式](https://kashw1n.com/blog/nodejs-2025/)

本文详细阐述了 Node.js 从早期回调函数和 CommonJS 主导的模式，演变为一个拥抱 Web 标准、内置丰富工具和现代异步模式的成熟开发平台的历程。文章重点介绍了截至 2025 年，现代 Node.js 开发的核心变革，包括 ESM 模块成为标准、内置 Web API 减少依赖、原生测试框架、先进的异步模式与流处理、Worker 线程、以及提升开发体验和安全性的诸多内置功能。这些变化旨在构建更简洁、高性能、可维护且与更广泛 JavaScript 生态系统对齐的应用程序。

- 📦 **模块系统革新**：ES 模块（ESM）已成为新标准，取代 CommonJS，支持静态分析和树摇优化。使用 `node:` 前缀引入内置模块使依赖关系更清晰。
- 🌐 **内置 Web API**：原生集成了 Fetch API、AbortController 等 Web 标准，大幅减少了对`axios`、`node-fetch`等外部 HTTP 库的依赖。
- 🧪 **原生测试支持**：Node.js 内置了功能完整的测试运行器，提供测试、描述、断言和监控模式，减少了对 Jest、Mocha 等外部测试框架的依赖。
- ⚡ **现代异步模式**：广泛使用顶层 await、Promise.all、AsyncIterators 以及结合 AbortController 的精细化错误处理，使异步代码更简洁、可控。
- 🔄 **先进的流处理**：Streams API 与 Web Streams 标准实现互操作，并通过`pipeline`函数简化了流处理与错误管理。
- 🧵 **Worker 线程实现并行**：通过 Worker Threads 将 CPU 密集型任务分流到独立线程，避免阻塞主事件循环，实现真正的并行计算。
- 🛠️ **增强的开发体验**：内置文件监控模式（`--watch`）、环境变量文件（`--env-file`）支持，减少了开发中对`nodemon`、`dotenv`等工具的需求。
- 🔒 **安全与性能监控**：引入实验性的权限模型来限制文件/网络访问，并提供内置的性能钩子（`perf_hooks`）进行应用性能监控。
- 📦 **应用分发简化**：支持将应用打包成单一可执行文件（Single Executable Applications），简化了部署和分发流程。
- 🐞 **现代错误诊断**：鼓励使用结构化的自定义错误类，并利用`diagnostics_channel`模块发布和订阅诊断信息，提升应用的可观测性。
- 🗺️ **模块管理进阶**：支持导入映射（Import Maps）来管理内部模块路径，以及使用动态导入实现按需加载和条件加载代码。

### [pnpm 10.26 | pnpm](https://pnpm.io/blog/releases/10.26)

pnpm 10.26 版本引入了更严格的安全默认设置，包括对 Git 托管依赖的脚本执行限制、新增 `allowBuilds` 配置以精细控制构建脚本权限，以及阻止非标准协议传递依赖的功能，同时增强了锁文件完整性和打包命令的预览支持。

- 🔒 Git 托管依赖现在默认阻止运行 `prepare` 脚本，需在 `allowBuilds` 中显式允许，防止恶意代码执行
- ⚙️ 新增 `allowBuilds` 配置，支持按包名灵活允许或禁止脚本执行，取代 `onlyBuiltDependencies` 和 `ignoredBuiltDependencies`
- 🚫 新增 `blockExoticSubdeps` 设置，可阻止传递依赖使用非标准协议（如 `git+ssh:`），仅允许直接依赖使用
- 🔐 为 HTTP tarball 依赖计算并存储完整性哈希到锁文件，确保后续安装时内容未被篡改
- 📦 `pnpm pack` 命令新增 `--dry-run` 选项，可预览打包文件列表而不实际创建压缩包
- 📋 在表格/列表格式中显示已弃用版本的最新状态
- 🧹 在 `deploy` 命令中从锁文件移除 `injectWorkspacePackages` 设置
- 🔗 标准化锁文件中 tarball URL 的存储格式，修复重定向不可变依赖的 URL 处理问题

## AI

### [ui-ux-pro-max-skill](https://github.com/nextlevelbuilder/ui-ux-pro-max-skill)

UI UX Pro Max 是一个为 AI 编程助手（如 Claude Code、Cursor、Windsurf 等）设计的技能/工作流，提供跨平台和框架的专业 UI/UX 设计智能。它包含丰富的设计数据库，支持自动搜索与推荐，帮助开发者快速生成符合最佳实践的界面。

- 🎨 **功能丰富** – 提供 57 种 UI 风格、95 个行业调色板、56 种字体搭配、24 种图表类型及 98 条 UX 指南。
- ⚙️ **多助手支持** – 支持 Claude Code、Cursor、Windsurf、Antigravity、GitHub Copilot 和 Kiro 等 AI 助手。
- 📦 **便捷安装** – 可通过 CLI 工具或手动复制配置文件快速集成到项目中。
- 🔍 **智能推荐** – 根据产品类型和需求自动匹配设计系统，生成符合规范的代码。
- 🖥️ **跨栈兼容** – 支持 HTML + Tailwind、React/Next.js、Vue/Svelte、SwiftUI/React Native/Flutter 等技术栈。
- 📈 **开源活跃** – 项目采用 MIT 许可证，拥有 1.3k 星标、315 分支和持续更新。

### [让你的编码代理通过 Chrome 开发者工具 MCP 调试浏览器会话](https://developer.chrome.com/blog/chrome-devtools-mcp-debug-your-browser-session)

本文介绍了 Chrome DevTools MCP 服务器的一项新增强功能：允许编程助手直接连接到活跃的浏览器会话。该功能支持复用现有登录状态、访问实时调试会话，并提供了从手动调试到 AI 辅助调试的无缝切换体验。文章详细说明了其工作原理、启用步骤以及应用场景。

- 🚀 **连接活跃浏览器会话**：编程助手可直接接入当前浏览器会话，无需重复登录，便于处理需身份验证的问题。
- 🔍 **访问实时调试会话**：助手能获取 DevTools UI 中的活跃调试数据，例如针对网络面板中的失败请求或元素面板中的选定元素进行分析。
- 🛡️ **安全权限控制**：Chrome 会通过弹窗请求用户明确授权远程调试连接，并显示提示横幅以防止恶意滥用。
- ⚙️ **简易启用步骤**：需先在 Chrome 中启用远程调试（通过`chrome://inspect`），然后在 MCP 服务器配置中添加`--autoConnect`参数。
- 🔄 **灵活连接方式**：该功能是对现有连接方式（如专用用户配置、远程调试端口等）的补充，支持自动化与手动操作并行。
- 🌟 **未来扩展计划**：团队计划逐步通过 Chrome DevTools MCP 服务器向编程助手开放更多面板数据。

## 其他

### [优秀技术主管的特质 ](https://world.hey.com/joaoqalves/traits-of-a-good-tech-lead-b5cac0ae)

本文探讨了软件工程团队中技术主管（Tech Lead, TL）与工程经理（Engineering Manager, EM）的角色定义、职责差异及高效工作模式。文章指出，TL 主要负责团队的技术方向，聚焦架构、质量与指导；EM 则侧重于人员、产品/项目与流程管理。两者可由不同人或同一人担任。文章重点阐述了优秀 TL 的行为特征与评估信号，并提供了促进团队自主性的实用工具。

- 🏗️ **TL 的核心职责**：负责团队的技术方向，涵盖架构决策、质量维护和工程师指导三大支柱，旨在成为团队的“乘数效应”来源，而非瓶颈。
- 👥 **EM 的核心职责**：专注于人员管理、产品/项目交付及流程优化，确保团队高效、独立运作。
- 🔀 **角色配置模式**：常见模式包括 EM 与 TL 由两人分任、由一人兼任，或仅设 EM 而由工程师承担技术领导职责。
- ✅ **优秀 TL 的行为信号**：善于使用 RFC 文档化决策、主动管理技术债务、协商技术范围、制定明确的团队操作原则，并能通过影响力（而非职权）推动共识。
- ⚠️ **低效 TL 的行为表现**：决策随意无记录、成为唯一知识枢纽、过度设计、回避困难对话、导致团队持续依赖个人。
- 🤝 **EM 与 TL 合一的情况**：此时需注重向上管理、向下授权，并在团队内培养各技术领域的“负责人”，以避免个人成为瓶颈。
- 🧭 **领导力原则**：通过明确、共创的操作原则减少主观争论，以结果为导向，利用实验（如概念验证）化解分歧，实现原则性领导。
- 🎯 **TL 的真正影响**：衡量标准在于团队是否每月减少对 TL 的依赖，即团队自主思考、决策和执行能力的提升。
- 🎁 **实践工具**：作者提供了免费的“对齐工具包”，包括 TL 自评、EM 评估和团队操作原则模板，以帮助明确期望、减少摩擦。

### [如何在局势日益失控时有效领导](https://hbr.org/2025/11/how-to-lead-when-things-feel-increasingly-out-of-control)

本文探讨了当代领导者面临的普遍恐惧与失控感，源于地缘政治动荡、人工智能颠覆和全球体系分裂三大力量的碰撞。恐惧会导致决策拖延、过度控制和组织叙事迷失。文章提出了五项应对策略：建立政策信息处理系统、采用“现实期权”投资法、制定清晰的 AI 应用原则、保护战略思考时间，以及主动设计地缘政治韧性方案。最终强调，卓越的领导力不在于消除恐惧，而在于将其转化为清晰度、勇气和共同目标。

- 🌪️ **三大恐惧源头**：地缘政治波动、人工智能渗透、全球体系分裂正在重塑商业环境，导致领导者陷入持续的不确定性与焦虑。
- 🧠 **恐惧的负面影响**：压力会窄化思维，导致决策拖延、微观管理盛行，团队失去长期愿景与创新动力。
- 📰 **建立信息处理系统**：通过跨职能政策小组定期分析政策信号，区分“噪音”与真实威胁，将焦虑转化为有序行动。
- 🪙 **采用“现实期权”投资法**：以分阶段、小规模的试点取代孤注一掷的巨额投资，通过市场反馈灵活调整，降低风险。
- 🤖 **明确 AI 应用原则**：制定清晰的 AI 使用边界与赋能路径，通过试点实验和技能重塑减少员工对替代的恐惧。
- ⏳ **保护战略思考时间**：领导者需在日程中固定“战略区块”，将长期规划视为核心职责，避免日常危机吞噬方向感。
- 🗺️ **主动设计地缘韧性**：通过供应链多元化、情景模拟和应急预演，将地缘政治风险转化为可管理的韧性计划。
- 🌟 **领导力的核心转化**：在恐惧时代，领导者的关键任务并非预测一切，而是通过坦诚、透明和系统化行动，将不确定性转化为团队凝聚力与共同目标。
