---
title: 2025-第三十二周
date: '2025-08-03'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [网络已不再以 URL 为形态 - Jono Alderson](https://www.jonoalderson.com/conjecture/url-shaped-web/)

现代网络已不再以 URL 为核心，机器（如搜索引擎、爬虫、AI 代理）对内容的处理方式与人类截然不同，它们更关注内容中的“断言”（离散的事实陈述）及其关联性，而非页面本身。以下是关键要点：

- 🌐 机器主导网络：超过一半的网站访问者是非人类，它们将 URL 视为“信封”，只提取其中的断言信息。  
- 🔍 传统 SEO 失效：过去以 URL 为单位的优化策略（如关键词排名、页面链接）已不适应机器优先的网络环境。  
- 🧩 断言成为核心：机器通过“三元组”（主语→谓语→宾语）或向量编码提取内容中的断言，评估其清晰度和关联性。  
- 🤖 信任基于图谱：机器通过知识图谱或统计模式验证断言的可靠性，一致性、多源佐证和权威引用是关键。  
- ⚠️ 敌对内容威胁：竞争对手或不良行为者可能污染数据，需主动监控并强化品牌断言的外部一致性。  
- ✍️ 双重优化策略：内容需兼顾人类体验（设计、故事性）和机器可读性（结构化数据、语义 HTML）。  
- 🛠️ 实践建议：  
  - 避免断言 spam，保持信息一致；  
  - 设计易于机器提取的页面（如明确标价、特征）；  
  - 通过 API/结构化数据提供机器友好接口；  
  - 借助第三方权威平台强化品牌背书。  
- 🔮 未来趋势：网络演变为“意义网络”，优化重点转向如何在机器模型中建立强关联、可信的断言节点。  

### [React Query 选择器，全面强化](https://tkdodo.eu/blog/react-query-selectors-supercharged)

React Query 的 `select` 功能详解：通过精细订阅优化渲染性能  

- 🔍 **全局状态与订阅**：React Query 通过 `QueryCache` 管理全局状态，`useQuery` 仅订阅特定 `QueryHash` 对应的数据变更，避免无关更新。  
- 🎯 **精细订阅需求**：当 API 返回大量数据但组件仅需部分字段时，`select` 可筛选目标字段，减少不必要的渲染（如仅订阅商品标题而非全部信息）。  
- ⚙️ **select 基础用法**：传递 `select` 函数到 `useQuery`，返回派生数据（如 `data.title`），组件仅在此结果变化时重新渲染。  
- 🔄 **多字段订阅**：支持返回包含多个字段的对象（如 `{title, description}`），结构共享确保引用稳定性。  
- 🧩 **TypeScript 集成**：类型自动推断 `select` 返回结果，无需手动泛型标注。抽象 `select` 时需使用泛型参数（如 `<TData = ProductData>`）。  
- 🚀 **性能优化**：  
  - 使用 `useCallback` 稳定 `select` 函数引用，避免重复计算（依赖项变化时重新执行）。  
  - 外部定义或 `memoize` 工具（如 `fast-memoize`）缓存昂贵计算，避免多组件实例重复处理相同数据。  
- ⚠️ **注意事项**：`select` 每次在 `QueryObserver` 级别运行，需结合外部缓存实现跨组件计算复用。

### [使用 React 解锁 Web Workers：分步指南](https://www.rahuljuliato.com/posts/react-workers)

这篇博客介绍了如何在 React 中使用 Web Workers 来提升界面响应速度，避免因繁重计算任务导致 UI 冻结的问题。文章从实际问题出发，逐步演示了 Web Worker 的实现、任务队列控制、跨标签页共享 Worker 等技术，并对比了 Web Worker、Shared Worker 和 Service Worker 的适用场景。

- 🚀 **博客背景**  
  - 作者将团队内部分享的 Web Workers 与 React 结合的内容整理成博客，并提供完整的 GitHub 代码示例。

- ❌ **问题：UI 冻结**  
  - 递归计算斐波那契数列等高耗时任务会阻塞 JavaScript 主线程，导致 React 界面无响应（如按钮卡顿、动画停滞）。  
  - 注意：CSS 动画由浏览器合成线程处理，不受主线程阻塞影响。

- 💡 **解决方案：Web Workers**  
  - 将繁重计算移至独立线程的 Web Worker 中，主线程保持响应。  
  - 示例：通过`postMessage`与 Worker 通信，异步获取计算结果。

- 🔄 **多任务处理与队列控制**  
  - 连续点击按钮时，默认并发执行任务可能导致乱序。  
  - 改进：在 Worker 内实现任务队列，确保按请求顺序依次处理。

- 🌐 **跨标签共享：Shared Workers**  
  - 使用 Shared Worker 实现多标签页共享资源（如缓存斐波那契计算结果），避免重复计算。

- 📊 **Worker 类型对比**  
  - **Web Worker**：单页临时任务，解放主线程。  
  - **Shared Worker**：多标签/组件间共享状态（如 WebSocket、缓存）。  
  - **Service Worker**：全局网络代理，支持 PWA 离线功能（非计算场景）。

- 🔧 **扩展工具**  
  - 推荐使用 Comlink 简化 Worker 通信，支持类本地函数调用。  

### [React Query 选择器，超级强化版 | TkDodo 的博客](https://tkdodo.eu/blog/react-query-selectors-supercharged)

React Query 的 `select` 功能是一个高级优化工具，适用于需要精细控制订阅和减少不必要渲染的场景。

- 🚀 **`select` 的作用**：允许从查询结果中选择或转换数据，使组件仅订阅特定部分，减少不必要的重新渲染。
- 🔍 **精细订阅**：适用于端点返回大量数据但组件仅需部分字段的情况，提升性能。
- 🛠 **使用示例**：通过 `select` 提取产品标题，避免因其他字段变化导致的重新渲染。
- 🔄 **多字段选择**：可以同时选择多个字段，React Query 会通过结构共享保持引用稳定性。
- 📜 **TypeScript 支持**：`select` 自动推断返回类型，无需手动指定泛型参数。
- ⚡ **性能优化**：结合 `useCallback` 或外部 memoization 库（如 `fast-memoize`）进一步减少重复计算。
- 🧩 **复用与抽象**：建议直接在使用处添加 `select` 而非抽象到选项中，以保持类型安全和灵活性。
- 🏆 **终极优化**：对于昂贵计算，使用 memoization 确保即使多次渲染也仅计算一次。

通过合理使用 `select`，可以在复杂应用中显著提升性能。

### [Rust、Python 与 TypeScript：新三巨头·初探](https://smallcultfollowing.com/babysteps/blog/2025/07/31/rs-py-ts-trifecta/)

Rust、Python 和 TypeScript 将成为未来主导的编程语言（移动市场除外），AI 编程的普及使语言选择更基于其核心优势而非个人偏好。这三种语言在静态类型、依赖管理和生态系统方面表现突出，适合不同场景。

- 🦀 Rust：适用于系统软件和高效率需求场景，强大的类型系统能提前捕获错误，生成高性能代码。  
- 🐍 Python：拥有丰富的数学和数值计算库，适合实验和原型设计，结合 mypy 和 pydantic 可实现强类型。  
- 🌐 TypeScript：原生支持浏览器和 Web 开发，类型系统有助于复杂前端项目的维护。  
- 🤖 AI 编程推动“面向思想的编程”：开发者更像架构师，专注于设计目标和关键逻辑，AI 工具处理具体实现。  
- 📦 生态系统至关重要：Rust 的 cargo、TypeScript 的 npm 和 Python 的 uv 等包管理器简化了依赖管理，加速开发。  
- 🛠️ 类型系统对 AI 协作尤为重要：高级类型（如 Rust 枚举和 TypeScript 接口）能约束 AI 输出，减少上下文遗忘导致的错误。  
- 💡 错误提示与引导更关键：清晰的编译错误信息帮助 AI 快速修正问题，而语法细节的重要性相对降低。  
- 🚀 低门槛的高效开发：AI 工具使“首席工程师”式的工作方式更普及，但新手仍需培养设计判断力。  

### [深入思考主题与色彩命名](https://css-tricks.com/thinking-deeply-about-theming-and-color-naming/)

作为前端开发者，作者对网站主题设计进行了深入思考，探讨了如何提升主题设计的灵活性、色彩丰富度和视觉层次感，并提出了改进现有设计模式的方案。以下是关键要点总结：

- 🎨 **色彩调色板的重要性**  
  - 现有框架（如 Tailwind、Pico CSS）提供多色调色板，但数量并非关键，需确保足够支持设计需求。  
  - 直接使用框架默认颜色会导致网站缺乏独特性，建议自定义调色板以建立品牌标识。

- ✏️ **手动设计调色板**  
  - 作者通过 Figma 手动设计，跳过不必要的色调（如 Splendid Labz 案例中省略 50-400 的粉色）。  
  - 可添加自定义变体（如“d”代表低饱和度），灵活适应设计需求。

- ⚙️ **程序化生成调色板**  
  - 推荐工具：RampenSau、Perceptual Palettes、Accessible Palette Generator。  
  - 生成后可手动调整，平衡效率与个性化。

- 🔄 **现有系统的局限性**  
  - 多数框架仅支持少量色调（如 DaisyUI 仅 2 种/颜色），限制设计表达。  
  - 语义类名（如`primary-background`）混淆了色彩层级与用途，导致灵活性不足。

- 🧩 **改进语义系统**  
  - 分离色彩层级（primary/secondary）与组件样式（如按钮的`light/heavy`）。  
  - 建议用数字表示色调（如`--color-primary-500`），直观且语义明确。

- 🌐 **全局变量与组件变量**  
  - 全局变量（如边框、过渡效果）提升一致性，减少重复代码。  
  - 组件变量可简化命名（如`--header-bg`替代`--card-header-bg`），保持灵活性。

- 📊 **适用场景分级**  
  - 单一主题可直接使用调色板变量。  
  - 多主题需更复杂系统（如作者提出的层级分离方案），适应大规模需求。

- 🔗 **扩展资源**  
  - 作者的设计系统 Splendid Styles 和 Splendid Layouts 实践了上述理念，可供参考。


### [译：与 Claude Code 共事的六周](https://sorrycc.com/six-weeks-of-claude-code)

作者 Orta Therox 分享了过去六周使用 Claude Code 进行编程的颠覆性体验，展示了 AI 工具如何彻底改变开发流程、提升效率并重塑技术决策模式。

- 🚀 **生产力爆发**：独自完成 20+ 项积压多年的技术债/创新任务（如 React Native 迁移、测试策略制定等），同时保持原工作计划  
- 🧠 **思维模式转变**：从"先决策后实施"变为"先尝试后决策"，通过快速原型验证可行性（如前端测试策略探索）  
- 🏗️ **架构革新**：新建"prototypes"monorepo，使游戏设计流程从数周缩短至数小时（案例：《Missing Link》快速发布）  
- 👥 **协作升级**：双仓库克隆策略实现并行开发，GitHub Action 自动生成 PR 加速 issue 处理  
- 🎯 **用户画像**：产品技术复合型人才获益最大，有效缓解"第一步焦虑"，实现全广度开发  
- ⚙️ **技术适配**：monorepo+ 明确技术栈（React/GraphQL 等）为 AI 提供优质上下文，显著提升生成质量  
- ⏱️ **时间魔法**：副业项目实现 10 倍效率提升（如 Adium 主题复现从 12 小时→2 小时）  
- 🤖 **使用哲学**：保持工具中立性（不追逐新模型），专注核心工作流，警惕"AI 刷屏"消耗决策力  
- 🧪 **学习范式**：建议新人采用"平行构建法"，通过对比人工/AI 方案加速成长  
- ⚠️ **风险案例**：需警惕 AI 的过度承诺（如虚假的性能提升声明）和硬编码作弊倾向  


## 工具

### [ForesightJS](https://github.com/spaansba/ForesightJS)

ForesightJS 是一个轻量级 JavaScript 库，通过预测用户意图预取内容，提升用户体验，支持桌面和移动设备，无需配置即可使用。  

- 🚀 **功能概述**：自动预测用户行为并预取内容，提高页面加载速度。  
- 🖱️ **设备支持**：适配桌面（鼠标轨迹预测、键盘导航）和移动设备（视窗检测、触摸事件）。  
- ⚡ **开箱即用**：无需配置，默认提供优化策略。  
- 🛠️ **开发工具**：内置 DevTools，可视化预测逻辑和回调执行。  
- 📦 **安装方式**：支持 pnpm、npm、yarn 安装。  
- 📝 **基础用法**：通过 `ForesightManager` 注册元素并设置预取逻辑。  
- 🔌 **框架集成**：兼容任意框架，已提供 Next.js 和 React Router 的现成方案。  
- ⚙️ **配置灵活**：支持全局和元素级自定义设置。  
- 🤖 **AI 辅助**：提供 `llms.txt` 和 `llms-full.txt` 帮助 AI 工具理解库功能。  
- 📂 **文档扩展**：所有文档均支持 Markdown 格式（URL 后加 `.md`）。  

### [react-animatable](https://github.com/inokawa/react-animatable)

react-animatable 是一个基于 Web Animations API (WAAPI) 构建的轻量级 React 动画库，体积小巧（约 1kB），支持高性能动画和动态关键帧，适用于 HTML、SVG、Canvas 等多种元素。  

- 🚀 **轻量高效**：每个钩子约 1kB（gzip 后），总库约 2kB。  
- 🎨 **广泛兼容**：支持 Web Animations API、ScrollTimeline 和 ViewTimeline，需注意浏览器兼容性。  
- ⚡ **动态动画**：支持通过参数生成动态关键帧，灵活控制动画效果。  
- 📚 **完善文档**：提供 API 参考、Polyfill 配置及示例代码，方便快速上手。  
- 🛠 **TypeScript 支持**：严格的类型检查，提升开发体验。  
- 🌟 **多场景适用**：适用于 React 组件、CSS-in-JS 库及原生 DOM 元素。  

### [recorder](https://github.com/TokenRollAI/recorder)

Recorder 是一款强大的 VS Code 扩展，能智能记录整个开发流程，包括终端命令、文件操作和代码修改，支持一键生成标准化操作文档（SOP），实现“记录一次，永久复用”。  

- 🛠️ **功能概述**：完整记录终端命令、文件操作和代码变更，自动生成结构化 JSON 日志。  
- 🔍 **智能集成**：自动识别 Git 跟踪文件，仅捕获有意义的差异内容，过滤.gitignore 文件。  
- 🚀 **零配置启动**：开箱即用，适配任何工作区，性能优化无负担。  
- 📂 **输出结构**：生成带时间戳的`operation.json`，包含命令、文件创建/删除、代码差异等操作。  
- ⚙️ **使用步骤**：安装插件 → 开始录制 → 停止后生成 SOP → 下次直接复用。  
- 📜 **支持环境**：需 VS Code 1.90.0+ 和 Git（用于差异检测）。  
- 🌐 **开源许可**：采用 CC-BY-NC-4.0 协议，贡献者可提交 Issues 或 PR 至 GitHub 仓库。  
- ✨ **核心价值**：“记录一次，永久自动化”，避免重复复杂工作流。


### [dyad](https://github.com/dyad-sh/dyad)

Dyad 是一个本地开源的 AI 应用构建工具，具有快速、隐私保护和跨平台的特点。它支持用户使用自己的 AI API 密钥，无供应商锁定，并提供了丰富的功能和资源。

## 更新

### [伏特 /vōlt/](https://www.vlt.sh/)

一款名为 vlt 的新型 JavaScript 包管理器及无服务器注册表正式亮相，由 npm 创始人 Isaac Schlueter 及原 npm 团队核心成员开发，旨在革新 JavaScript 包管理生态，提供更高效、安全的开发与分发体验。

- 🚀 **vlt 发布**：推出全新 JavaScript 包管理器和无服务器注册表，致力于提升包管理效率与安全性。  
- 💡 **强大团队**：npm 创始人 Isaac Schlueter 及原班人马加盟，技术背景深厚。  
- 🔧 **功能亮点**：支持开发、运行、分发、发现及安全管控，提供熟悉的命令行工具（如`vlt [command]`）和 GUI 界面。  
- 🌐 **无服务器注册表**：支持自定义包和私有代码的安全分发，免除企业级高额费用。  
- 📢 **行业反响**：开发者社区高度关注，认为其填补了 npm 的创新停滞，可能成为未来主流工具。  
- 🔗 **资源链接**：官网[vlt.sh](https://vlt.sh)提供安装指南（`npm i -g vlt`）及文档。  
- 🔍 **特色功能**：查询语法（如`vlt view`）获好评，精准性优于现有方案。  
- 🎤 **活动亮相**：在#NodeConfEU 大会首发，Socket 博客深度报道其 6 个月开发成果。

### [如何在 React Router 中处理延迟数据 - sergiodxa](https://sergiodxa.com/tutorials/handle-deferred-data-in-react-router)

React Router v7 允许在加载器中返回未解决的 Promise，从而实现在组件中直接处理加载状态，提升用户体验。React 19 进一步简化了异步数据渲染的流程。

- 🚀 **延迟数据处理**：React Router v7 允许从加载器返回 Promise，无需在加载器中等待，直接在组件中处理加载状态。  
- 🔄 **与 Remix 的对比**：类似 Remix v2 的 `defer` 和 `useDeferredValue`，但 React Router v7 无需额外工具，直接返回 Promise 即可。  
- ⏳ **使用 Await 组件**：通过 `Suspense` 和 `Await` 组件结合，优雅地处理异步数据加载和加载状态。  
- ⚡ **React 19 的 use 钩子**：React 19 引入 `use` 钩子，可直接在组件中消费 Promise，但需要额外封装组件。  
- ✨ **Promise 作为可渲染节点**：React 19 允许直接将 Promise 作为渲染节点，无需 `Await` 或额外组件，简化代码。  
- 📚 **相关教程**：包括复用路由模块、拆分路由配置和动态加载样式表等 React Router v7 相关教程。

## 设计

## AI

### [Qwen-Image：原生文本渲染技术精研](https://qwenlm.github.io/blog/qwen-image/?utm_source=substack&utm_medium=email)

Qwen-Image 是一款 20B 参数的 MMDiT 图像基础模型，在复杂文本渲染和精准图像编辑方面取得显著突破，支持中英文高保真生成及多任务编辑，并在多项基准测试中表现优异。  

- 🚀 **模型发布**：推出 Qwen-Image 20B MMDiT 图像基础模型，支持通过 Qwen Chat 体验“图像生成”功能。  
- ✍️ **文本渲染**：擅长复杂文本布局（多行段落、精细细节），中英文均能高保真呈现，如对联、书籍封面、PPT 文字等。  
- 🖼️ **图像编辑**：通过多任务训练实现语义与视觉真实性的高度保留，支持风格迁移、物体增减、文字修改等操作。  
- 📊 **性能领先**：在 GenEval、DPG 等生成基准和 GEdit、ImgEdit 等编辑任务中均达到 SOTA，中文文本生成优势显著。  
- 🌟 **多场景示例**：  
  - 宫崎骏动漫风格古街场景，精准生成“云存储”“千问”等中文标识。  
  - 英文书店橱窗广告、诗歌手稿等微小文字还原。  
  - 中英双语混合文本（如技术介绍）无缝切换渲染。  
- 🎨 **艺术创作**：支持多种风格（写实、水墨、动漫等），可生成电影海报、企业 PPT 等专业内容。  
- 🔧 **编辑能力**：支持风格转换、细节增强、角色姿势调整等，降低专业图像编辑门槛。  
- 🌍 **愿景**：推动图像生成技术普及，构建开放可持续的生成式 AI 生态，鼓励社区参与反馈。


### [AI 代理的上下文工程：构建 Manus 的经验教训](https://manus.im/zh-cn/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus)

Yichao 'Peak' Ji 在 Manus 项目初期面临关键决策：选择开源基础模型端到端训练，还是基于前沿模型的上下文学习能力构建智能体。最终选择了后者，通过上下文工程实现快速迭代和产品正交性，尽管这一过程充满挑战。以下是关键经验总结：

- 🚀 **上下文工程的选择**：基于 GPT-3 和 Flan-T5 的上下文学习能力，放弃传统微调，实现小时级改进交付，保持与模型进步的兼容性。  
- 🔍 **KV 缓存优化**：KV-cache 命中率是生产阶段代理的核心指标，显著影响延迟和成本。通过稳定提示前缀、只追加上下文和标记缓存断点来提升效率。  
- 🛠️ **动态工具管理**：避免在迭代中动态增减工具，采用上下文感知的状态机遮蔽 logits，确保动作选择稳定且高效。  
- 💾 **文件系统作为上下文**：利用文件系统作为不受限的持久化存储，实现可恢复的压缩策略，解决长上下文窗口的痛点和信息丢失风险。  
- 📝 **复述操控注意力**：通过创建和更新待办列表（如 todo.md），将全局目标复述到上下文末尾，避免模型在长任务中偏离主题。  
- ❌ **保留错误内容**：将失败尝试保留在上下文中，帮助模型隐式更新内部信念，降低重复错误的概率，提升适应性。  
- 🔄 **避免少样本陷阱**：引入行动和观察的多样性，打破固定模式，防止模型陷入过度模仿和泛化，增强鲁棒性。  
- 🧩 **上下文工程的重要性**：尽管模型能力提升，上下文设计仍是智能体行为、速度和恢复能力的关键，需通过反复实践优化。


### [claude-code-templates](https://github.com/davila7/claude-code-templates)

这是一个关于 Claude Code Templates 项目的概述，该项目是一个用于配置和监控 Claude Code 的 CLI 工具，提供快速项目设置和实时监控功能。

- 🚀 **快速开始**：提供交互式设置、实时分析仪表板、聊天 Web 界面和系统健康检查命令。  
- ✨ **核心功能**：包括智能项目设置、实时分析、健康检查、独立组件安装等。  
- 🌐 **浏览与安装组件**：支持通过交互式 Web 界面探索和安装模板、代理、命令和 MCPs。  
- 📖 **文档**：包含完整的指南、示例和 API 参考，涵盖从入门到高级使用的各个方面。  
- 🤝 **贡献**：欢迎开源社区贡献，提供组件浏览和贡献指南。  
- 📄 **许可证**：项目采用 MIT 许可证，包含多个来源的组件集合。  
- 🔗 **链接**：提供组件浏览、文档、问题讨论和安全政策等相关链接。  
- ⭐ **支持项目**：鼓励用户通过点赞支持项目发展。  
- 🔧 **最新发布**：v1.14.9 版本修复了 MCP 安装深度合并问题。  

### [WebAgent](https://github.com/Alibaba-NLP/WebAgent)

- 🤗 **模型发布**  
  - WebShaperQA、WebSailor-3B、WebDancer-QwQ-32B、WebWalkerQA 等多个模型已发布，部分支持一键部署。  
  - 相关论文（预印版或 ACL 2025）涵盖数据合成、超人类推理、自主信息搜索等研究方向。  

- 📅 **时间线更新**  
  - 2025.07.22：发布 WebShaper，提出基于任务形式化的数据合成方法。  
  - 2025.07.11：WebSailor-3B 上线，支持阿里云 FunctionAI 快速部署。  
  - 2025.06.23：开源 WebDancer 的模型、交互演示及部分数据。  

- 💎 **核心功能**  
  - **WebShaper**：通过形式化方法生成信息搜索数据集，在 GAIA 和 WebWalkerQA 基准上达到 SOTA。  
  - **WebSailor**：后训练方法支持复杂任务推理，在 BrowseComp 和 GAIA 基准表现优异。  
  - **WebDancer**：基于 ReAct 框架的自主搜索模型，GAIA 和 WebWalkerQA 通过率超 60%。  

- 🚀 **快速上手**  
  - 提供 WebDancer 的环境配置、模型部署（需 HuggingFace 下载）和演示运行指南（需 API 密钥）。  

- 🎥 **演示案例**  
  - WebSailor 和 WebDancer 提供多场景演示视频（如 BrowseComp、GAIA），展示复杂任务处理能力。  

## 其他

### [不，人工智能并没有让工程师的效率提高十倍](https://colton.dev/blog/curing-your-ai-10x-engineer-imposter-syndrome/)

作者因社交媒体上“10 倍效率 AI 工程师”的言论陷入自我怀疑，但通过实际体验和理性分析，发现这些说法夸大其词，并分享了自己的观察和思考，帮助读者缓解焦虑。

- 🤔 **自我怀疑的起源**：作者因社交媒体上“AI 工程师效率提升 10-100 倍”的言论感到技能落后，但最终发现这些说法并不属实。  
- 🧐 **实际体验 AI 编码**：尝试多种 AI 编程工具后，发现 AI 在编写样板代码（如 React）时表现尚可，但在复杂代码库、特定语言（如 Terraform）或非主流库中表现糟糕，且容易产生安全漏洞。  
- 📉 **效率提升的数学质疑**：10 倍效率意味着将 3 个月的工作压缩到 1.5 周，但实际开发中的协作、评审、测试等环节无法同步提速，这一说法站不住脚。  
- 🚀 **真正的“10 倍工程师”**：少数高效工程师的价值在于减少不必要工作（如优化流程、文档化），而非单纯编码速度，而 AI 对此帮助有限。  
- 🤨 **AI 宣传背后的动机**：夸大 AI 效率的群体包括自我误测者、AI 行业利益相关者，以及试图让员工感到不安的老板。  
- 🎯 **短期效率假象**：AI 仅在特定场景（如一次性脚本）中显著提效，但长期使用后收益递减，且可能因代码质量差反而降低整体效率。  
- 💡 **理性看待 AI 工具**：使用 AI 编码并不难学，但无需因焦虑强迫自己接受；工作方式应优先考虑个人舒适度，而非盲目追求“效率”。  
- 😌 **接受自己的节奏**：即使 AI 能提升 20% 效率，也不必牺牲工作乐趣；享受编程过程才能长期保持创造力和代码质量。  
- ⚠️ **警惕制造焦虑的言论**：老板或行业炒作可能刻意渲染“AI 替代危机”，但实际工程瓶颈仍在人类协作与系统设计。  
- 🎵 **类比说明**：就像黑胶唱片虽“低效”却更让人愉悦，编码方式的选择应服务于个人幸福感，而非绝对生产力。  
- 👨💻 **给管理者的建议**：营造健康工程文化，避免用不切实际的 AI 效率预期压迫团队，尊重工程师的专业判断。  
- ✋ **最终结论**：没有神秘的“AI 效率革命”，信任自身能力，远离制造焦虑的社交媒体。


---

### [你不是在 vibe coding，而是在十倍速生成屎山](https://ameow.xyz/archives/vibe-coding-or-shit-generating)

作者花费 10 小时使用 AI 编程工具（Cursor 和 Claude Code）开发了一个安卓设备管理工具，并分享了使用心得和工具优缺点。

- 🚀 **功能实现**：开发了设备列表展示、屏幕实时监控（scrcpy）和 ADB 命令执行功能  
- 💸 **成本消耗**：Cursor Pro 额度耗尽，Claude Code 花费约十几美元，生成代码约 10000 行  
- ⚠️ **代码质量**：作者自嘲为"十倍速生成屎山"，代码风格混乱且难以维护  
- 🤖 **AI 使用心得**：AI 决定下限，人决定上限；对功能不熟悉时容易失去对代码的控制  
- 👍 **工具优点**：自动上下文选择、任务规划、文档查询和自动 lint 修复功能优秀  
- 👎 **工具缺点**：容易陷入调试循环、过度使用 mock 实现、烧钱快、架构理解能力弱  
- 📚 **使用技巧**：推荐使用 DeepWiki 和 context7 补充上下文，按需求选择合适模型  
- 📝 **规范建议**：建立代码规范、拆分原子化函数、提高代码可读性以提升 AI 表现  
- 🤔 **最终结论**：AI 能提升效率但有限，使用者的认知水平和技巧决定 AI 能力上限