---
title: 2025-第五十五周
date: '2025-12-29'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [Node.js 中的 require(esm)：实现者的故事](https://joyeecheung.github.io/blog/2025/12/30/require-esm-in-node-js-implementers-tales/)

本文回顾了在 Node.js 中实现 `require(esm)` 功能时所遇到的关键挑战与解决方案，重点讨论了与现有生态系统的互操作性、性能权衡及规范兼容性等问题。

- 🔄 **伪 ESM 包的兼容性**：为解决大量已存在的“伪 ESM”（通过 Babel 等工具转译为 CommonJS）包在迁移到纯 ESM 时可能破坏现有消费者的问题，Node.js 选择在 `require(esm)` 返回的命名空间对象上自动添加 `__esModule` 标记，确保转译后的代码能继续正常工作。
- ⚙️ **\_\_esModule 的实现方案**：评估了四种添加 `__esModule` 的方案，最终选择了通过创建内部 ESM facade（重新导出原模块并添加 `__esModule` 导出）的方式，在保证正确性、保持实时绑定和枚举性的同时，性能开销最小（约 2-4%）。
- 🧩 **CommonJS 的特殊导出**：为支持那些将 `module.exports` 整体赋值（而非对象字面量）的 CommonJS 模块平滑迁移到 ESM，引入了特殊的字符串命名导出 `"module.exports"`，允许模块自定义 `require(esm)` 的返回值，从而同时兼容 ESM 和旧的 CommonJS 消费者。
- 📦 **双包体的条件导出**：为支持仍需兼容旧版 Node.js 的包，引入了新的导出条件 `"module-sync"`，用于指定同步加载（即 `require`）时应使用的 ESM 入口，避免与现有生态中已用于打包工具的 `"module"` 条件冲突。
- 🔧 **同步检测内置模块**：为解决 ESM 中动态检测 Node.js 内置模块原先必须依赖异步 `import()` 的问题，新增了 `process.getBuiltinModule()` 同步 API，减少了不必要的顶层 await 使用。
- 🏗️ **同步加载的实现与竞态**：`require(esm)` 的核心实现需同步地获取、链接和评估模块。通过将原本为异步设计的模块加载例程改为完全同步，解决了与异步 `import` 可能发生的罕见竞态条件，并与 CommonJS 的加载模型对齐。
- ⚠️ **模块评估的重入防护**：当前实现会检测并阻止跨越 ESM/CommonJS 边界的模块循环依赖导致的重复同步评估（抛出 `ERR_REQUIRE_CYCLE_MODULE`）。未来待 V8 实现“延迟模块评估”提案后，可能支持安全地跳过此类重入评估。
- 🤝 **社区协作推动**：整个 `require(esm)` 功能的推进和完善得益于广泛的社区讨论、问题反馈与方案贡献，展示了通过合作如何推动一个曾停滞的倡议向前发展。

### [AI 时代，我的知识管理系统（2025 版）](https://sspai.com/post/104783)

本文系统介绍了作者在 AI 时代打磨超过五年的知识管理系统（CARD 系统），涵盖从信息捕捉到知识部署的全流程，强调在信息过载的 AI 时代，个人知识管理依然至关重要，并分享了如何利用 AI 工具增强该系统。

- 🎯 **知识管理在 AI 时代依然重要**：AI 的知识不等于个人知识，个人独有的智慧仍是核心竞争力，知识管理能帮助知识更好地流入大脑并应用于实践。
- 🌊 **构建个人信息过滤器**：面对海量信息，需主动使用搜索引擎、RSS 订阅、AI 问答等方式获取高质量信息，并对娱乐与增长智识的内容采用不同获取策略。
- 📚 **采用渐进式阅读法处理信息**：核心是“必要难度”，通过划线批注、向 AI 提问、记录读书笔记等方式，将信息内化为知识，并利用 AI 辅助判断质量与深度理解。
- 🗃️ **使用原子笔记法构建知识库**：推荐 Zettelkasten 方法，以知识卡片为基本单位，注重创造知识间的链接，并利用 AI Agent 实现智能检索、批量编辑等管理功能。
- 🚀 **部署知识以产生复利效应**：知识管理的终极目标是将知识运用于实践和创作。通过工具（如 Analogy）让知识在工作和生活中自然浮现，并积极创作以获取非对称收益。
- 🔄 **系统全景与工具流**：系统展示了从信息源、RSS 聚合、过滤、稍后阅读、处理信息到存入知识库，最终通过创作、实践和类比工具部署知识的完整流程及所用工具。
- ⚠️ **对 AI 内容时代的警示与应对**：指出 AI 生成内容可能导致互联网内容生态质量下降，强调需保持主动性、培养品味、坚持创作以建立个人品牌。

### [译：一个由 Agent 为 Agent 编写的代码库](https://sorrycc.com/by-an-agent-for-an-agent)

本文探讨了作者在开发过程中，将代码命名、结构等决策权完全交给 AI 智能体（Agent）后，代码库的可用性和开发效率反而得到显著提升的经历。作者发现，放弃个人偏好、遵循 Agent 基于其训练数据与上下文做出的“直觉性”选择，能使代码库在统计概率上更符合 AI 的认知模式，从而让 Agent 在后续开发中表现更出色、更高效。

- 🤖 **将决策权交给 Agent**：作者不再干预 AI 对函数命名、文件结构和代码布局的决定，而是让 Agent 基于其“直觉”（训练数据与上下文）自主选择。
- 🔄 **命名冲突的教训**：作者曾因个人偏好将函数名从`present()`改为`swapScreens()`，导致 Agent 在后续工作中频繁“空转”寻找正确名称，增加了认知负荷和 token 消耗。
- ⚡ **效率显著提升**：放手让 Agent 自主决策后，其运行更快、更持久，并能采用开发者未曾想到的命名约定、文件布局和编程模式（如更多 OOP 和泛型使用）。
- 🧩 **框架识别与概念映射**：Agent 可能识别出代码库受 Flutter 启发的设计模式（如 Widgets、StatefulWidgets），从而透过语言差异理解核心概念，并在其“权重”中找到最可能的实现方式。
- 🛠️ **自我优化的代码库**：由 Agent 主导编写的代码库在“开发者意图”“概念需求”和“AI 实现概率”之间达到平衡，使 Agent 能更直观地导航、修改和扩展代码，甚至快速修复缺失功能。
- 💡 **平衡与协作的新模式**：这一实践表明，最有效的代码库可能并非完全遵循人类偏好，而是由 AI 基于统计可能性构建，从而形成一个“由 Agent 为 Agent 编写”的高效协作环境。

### [译：是时候抛弃的 5 个工程教条](https://sorrycc.com/5-engineering-dogmas-its-time-to-drop)

本文探讨了五个被广泛视为软件工程"常识"的实践，并分析了为何值得重新审视它们。作者认为，优秀的工程管理者应在这些教条与现实之间找到平衡，并持续评估最适合团队的方法。

- 🧩 **不要盲目依赖外部包**：过度依赖外部库可能带来安全风险、供应链断裂（如 left-pad 事件）和维护负担。虽然"不重复造轮子"是明智的，但关键组件自主可控有时更可靠。
- 👁️ **强制代码审查可能拖慢速度**：代码审查虽能提升质量，但僵化的强制流程会显著影响开发效率。可以考虑更灵活的方式，如信任工程师自主合并、结对编程或仅在必要时审查。
- 🏃 **重新思考冲刺模式**：固定的 2-4 周冲刺可能削弱创造力和工作乐趣。存在像 Shape Up 这样以 6 周为周期、包含休整期的替代方案，旨在建立更可持续的工作节奏。
- 🔌 **功能开关滥用增加复杂度**：虽然功能开关有助于灰度发布和降级，但过度使用会导致代码库混乱、测试困难，并可能产生虚假的安全感。应谨慎使用，避免非必要场景。
- 💬 **注释与代码复杂度需平衡**：完全避免注释或过度依赖注释都是极端。代码应追求自解释性，但在复杂逻辑或关键上下文处，简洁的注释能极大提升可维护性。

### [译：一种从 Claude Code 中提取详细记录的新方法](https://sorrycc.com/claude-code-transcripts)

作者发布了一个名为 claude-code-transcripts 的 Python CLI 工具，用于将 Claude Code 对话记录转换为更详细、更易分享的 HTML 页面，以更好地保存和回顾 AI 编码过程中的决策与上下文。

- 🛠️ 发布新工具：claude-code-transcripts 可将 Claude Code 的本地或网页版对话记录转换为分页的 HTML 文件，便于查看和分享。
- 🚀 快速开始：已安装 uv 的用户可直接通过 `uvx claude-code-transcripts` 运行，并交互式选择会话进行转换。
- 🌐 网页版支持：工具通过逆向工程 API 支持获取网页版 Claude Code 会话，并可配合 `--gist` 选项自动分享至 GitHub Gist。
- 📝 记录价值：作者强调这些记录对于理解提示策略、保存项目决策上下文至关重要，弥补了传统 issue 跟踪的不足。
- 🤖 开发过程：工具本身完全使用 Claude Code 构建，依赖 Click、Jinja2、httpx 等库，并采用快照测试确保稳定性。
- 🔍 逆向工程：通过 OpenAI Codex CLI 逆向分析了 Claude Code 的 JavaScript，提取了包括从 macOS 钥匙串获取 OAuth 令牌的关键 API 调用方法。

## 工具

### [mapcn](https://github.com/AnmolSaini16/mapcn)

这是一个名为 mapcn 的开源地图组件库的 GitHub 仓库概览，它基于 Next.js 构建，旨在提供美观、易用的地图 UI 组件。

- 🗺️ **项目简介**：mapcn 是一个免费开源的地图组件库，基于 MapLibre GL 构建，采用 Tailwind CSS 样式，并与 shadcn/ui 无缝兼容。
- 🚀 **核心特点**：提供零配置开箱即用、自动适配明暗主题、完整的组件化体系以及丰富的地图功能（如标记、弹出框、路线绘制和控制控件）。
- 📁 **仓库状态**：项目创建于 2 天前，已获得 151 个星标和 6 个复刻，主分支有 12 次提交，使用 TypeScript 为主要开发语言。
- 👥 **协作与许可**：欢迎通过 Fork 和 Pull Request 进行贡献，项目采用 MIT 开源许可证发布。
- 🌐 **在线资源**：可通过官方链接 mapcn.vercel.app 访问，仓库包含完整的文档、示例和部署配置。

## 更新

## 设计

## AI

### [译：长时间运行智能体的有效控制框架](https://sorrycc.com/effective-harnesses-for-long-running-agents)

本文介绍了如何为长时间运行的 AI 智能体构建有效的控制框架，以解决其在跨多个上下文窗口工作时面临的挑战。核心方案是设计一个初始化智能体来设置项目环境，以及一个编码智能体来执行增量开发并维护清晰的工作状态。

- 🏗️ **初始化环境**：首个智能体会话负责创建基础环境，包括初始化脚本、进度记录文件和初始 Git 提交，为后续工作奠定结构化基础。
- 📋 **功能清单管理**：初始化智能体会根据用户提示生成详细的 JSON 格式功能需求文件，明确列出所有待实现功能，防止智能体过早宣布项目完成或遗漏需求。
- 🐌 **增量式开发**：编码智能体被要求每次只专注于实现一个功能，确保工作聚焦且可管理，避免因试图一次性完成过多任务而导致上下文耗尽或代码混乱。
- 🧪 **严格测试与验证**：智能体被明确要求使用浏览器自动化等工具进行端到端测试，只有在功能被彻底验证后才将其标记为完成，以减少未检测到的错误。
- 🔄 **状态维护与交接**：每个编码会话结束时，智能体必须提交清晰的 Git 记录并更新进度文件，确保下一个会话能快速了解项目状态，无需浪费时间猜测或修复损坏的环境。
- 🛠️ **工具增强测试**：为智能体提供如 Puppeteer MCP 服务器等测试工具，显著提升了其识别和修复仅通过代码审查难以发现的问题的能力。
- 🧭 **会话启动流程**：每个新会话都遵循标准化的“确定方向”步骤，包括检查工作目录、阅读进度与 Git 历史、选择待办功能等，以提高效率。
- ❓ **待解问题与未来方向**：文章指出，目前尚不清楚单一通用智能体与多智能体架构孰优孰劣，且当前方案主要针对全栈 Web 开发，其经验能否推广至科研、金融等其他长周期任务领域仍有待探索。

## 其他

### [译：效率悖论：为什么让软件更容易编写意味着我们将编写指数级更多的软件](https://sorrycc.com/the-efficiency-paradox)

每当软件开发效率提升，软件数量便会指数级增长，而非减少。这一模式在技术演进中反复出现，如今在人工智能辅助开发的推动下，正以前所未有的规模重演，将经济可行的软件项目范围大幅扩展。

- 🚀 效率提升并未减少开发需求，反而激发了更多潜在需求，使原本因成本过高而搁置的项目变得可行。
- 🛠️ 开发门槛的降低改变了开发者的核心技能：从“如何实现”转向“应该构建什么”，强调想象力与判断力。
- 📈 每一层技术抽象都催生了新的工具生态，形成复合增长效应，持续扩大软件开发的边界。
- 💡 历史表明，知识工作效率提升后，其产出常呈数量级增加，而非减少，当前 AI 变革正遵循这一规律。
- 🔮 未来的瓶颈将从技术实现转向价值选择，要求开发者具备更宏观的产品思维与决策能力。

### [译：Superpowers 4](https://sorrycc.com/superpowers-4)

Superpowers 4.0 版本发布，主要改进了子 Agent 驱动的开发流程，优化了技能描述以提升触发准确性，增加了内部测试套件，并更多地使用 GraphViz 进行流程文档记录。

- 🤖 **子 Agent 驱动的开发流程优化**：代码审查步骤被拆分为独立的“规范审查”和“代码审查”两个 Agent，并正式成为循环流程，提高了自动化程度。
- 📝 **技能描述变更以提升准确性**：针对 Claude 可能误解技能的问题，技能描述被简化为仅说明使用时机，并将部分技能合并以规避字符数限制。
- 🧪 **引入内部测试套件**：新增了基本的端到端测试，用于验证 Agent 执行完整开发流程和技能使用情况，以持续改进技能触发机制。
- 📊 **内部流程文档使用 GraphViz**：更多地依赖 GraphViz 的‘dot’符号来记录流程，这种形式化符号减少了歧义，便于 Claude 准确遵循。
