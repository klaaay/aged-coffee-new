---
title: 2025-第四十七周
date: '2025-11-10'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [实验：使 TypeScript 默认不可变](https://evanhahn.com/typescript-immutability-experiment/)

作者尝试在 TypeScript 中实现默认不可变变量，通过禁用内置库并自定义类型定义，成功使数组和 Record 类型默认不可变，但未能实现普通对象的默认不可变性。

- 🚫 禁用 TypeScript 内置库，通过设置 noLib 标志移除默认可变类型定义
- 🧩 创建基础类型定义文件 lib.d.ts，包含空接口作为类型占位符
- 🔒 通过 readonly 修饰符成功实现数组的默认不可变性，禁止直接赋值和 push 等操作
- 🔄 定义 MutableArray 接口实现可控的可变数组，需显式声明
- 📝 扩展方案到 Record 类型，分别定义不可变 Record 和可变 MutableRecord
- ❌ 普通对象`{foo:"bar"}`的默认不可变性实现失败，无法通过修改 Object 接口达成
- 💡 建议未来可通过 lint 规则强制实现完全不可变，或等待语言原生支持

### [Visual Types 摘要](https://types.kitlangton.com/)

- 🏷️ 类型是运行时值集合的标签，包括布尔值、字面量类型和联合类型等。
- 📊 子类型关系使用 `extends` 表示，若类型 A 是 B 的子集，则 `A extends B` 成立。
- 🧩 元组类型是固定长度且各位置类型确定的数组，对象类型则通过属性定义集合。
- 🔀 联合类型使用 `|` 组合多个类型，交集类型使用 `&` 取共同部分，无交集时为 `never`。
- 📝 类型别名允许为类型命名，泛型类型别名则像类型级函数，接受类型参数并返回新类型。
- 🔧 `typeof` 操作符在编译时提取值的类型，`as const` 将对象属性设为只读字面量类型。
- 🔑 `keyof` 提取对象所有键的联合类型，索引访问类型通过键查找属性类型。
- 🗺️ 映射类型通过迭代键来创建新对象类型，条件类型则根据条件判断选择不同类型。
- 🔄 条件类型在处理联合类型时会进行分布式计算，可用元组包装来禁用此行为。
- 🛠️ 实用工具类型如 `Pick`、`ReturnType` 和 `Parameters` 等，提供了常见的类型操作功能。

### [React 中的计时器同步机制](https://www.dzialowski.eu/synchronizing-timers-react/)

当应用中多个组件需要以相同间隔执行操作但计时器不同步时，可以使用自定义钩子实现定时器同步。

- 🎯 问题场景：闪烁按钮组件与进度条组件使用独立计时器，导致动画效果不同步
- ⚙️ 初始方案：使用 useInterval 钩子独立管理间隔，但组件间状态相互隔离
- 🪣 核心思路：创建按延迟时间分组的“桶”机制，同间隔的回调函数归入同一桶
- 🛠️ 技术实现：通过 setupBucket 函数管理间隔实例，add/remove 函数控制回调队列
- 📦 钩子设计：useSynchronizedInterval 接收函数与延迟参数，自动加入对应桶
- 🎉 使用效果：替换 useInterval 后，多个组件可实现毫秒级精确同步
- 🔧 扩展能力：支持通过 id 参数为相同延迟创建独立桶，满足复杂场景需求

### [DNS 解析累加效应 | 亚历克斯·麦克阿瑟](https://macarthur.me/posts/dns/)

本文探讨了 DNS 预解析（dns-prefetch）资源提示对前端性能的优化作用，通过提前解析第三方域名来减少延迟，并对比了 preconnect 和 preload 等资源提示的使用场景与效果。

- 🌐 DNS 解析虽快但非零成本，多域名访问时延迟会累积
- ⚡ DNS 预解析可提前获取 IP 地址，优化不确定的第三方资源请求
- 📊 实测显示常见网站 DNS 解析耗时可达 100-300 毫秒
- 🔄 对比三种资源提示：dns-prefetch 仅解析 DNS、preconnect 建立完整连接、preload 直接预加载资源
- 🎯 使用建议：不确定资源用 dns-prefetch，确定连接用 preconnect，关键资源用 preload
- 💡 资源提示属于精细化优化工具，需结合具体场景使用
- 📈 正确使用可提升页面加载性能，但需注意 preload 的 URL 精确匹配要求

### [React 19.2：React 进入其巅峰时代 - DEV 社区](https://dev.to/sagi0312/react-192-react-in-its-sigma-era-op7)

React 19.2 版本以幽默风格介绍了其新特性和改进，强调框架在性能优化和开发者体验上的提升，包括自动编译优化、组件状态保持、副作用管理、性能调试工具等，标志着 React 进入更成熟高效的"sigma 时代"。

- 🚀 **React Compiler 自动优化** - 通过 Babel 插件实现自动记忆化，减少手动优化时间，尽管可能略微增加构建时间
- 🎭 **Activity 组件** - 允许组件在隐藏时保持状态和 DOM，避免重复挂载卸载，提升用户体验
- 🧘‍♀️ **useEventEffect Hook** - 减少不必要的重渲染，更稳定地处理事件回调，避免依赖项频繁更新
- 🫠 **cacheSignal API** - 为服务器组件缓存提供中止信号，适用于高流量应用的边缘场景
- 📊 **性能追踪工具** - 在 Chrome DevTools 中显示调度器和组件渲染时间，帮助调试性能问题
- 🍱 **部分预渲染 (PPR)** - 支持静态外壳和动态内容流式传输，需配合框架如 Next.js 使用
- 🤝 **Suspense 边界批处理** - SSR 期间同步加载多个异步组件，避免内容逐个闪现
- 🔧 **工具更新** - eslint-plugin-react-hooks v6 支持 useEffectEvent 和扁平配置，useId 前缀更新为兼容 View Transitions API

## 工具

### [marmelab/shadcn-admin-kit：基于 shadcn/ui 构建管理应用的组件套件](https://github.com/marmelab/shadcn-admin-kit)

这是一个基于 shadcn/ui 构建管理后台应用的组件套件，提供完整的 CRUD 页面、数据表格、表单验证、权限控制等功能，支持多种技术栈和 API 类型。

- 🛠️ 基于 shadcn/ui 和 Radix UI 的组件库，用于快速构建管理后台应用
- 📊 提供完整 CRUD 功能：列表、详情、编辑和创建页面
- 🎯 数据表格支持排序、筛选、导出、批量操作和分页
- 🔐 内置登录认证和权限控制，兼容各种认证后端
- 🌐 支持国际化、明暗主题和响应式设计
- 🔄 兼容 REST、GraphQL 等多种 API 类型
- ⚡ 支持 Vite.js、Remix、Next.js 等现代前端框架
- 🎨 使用 Tailwind CSS 进行样式设计，Lucide 图标库
- 📝 表单组件支持数据绑定和验证
- 🚀 提供代码猜测器，可根据 API 响应自动生成组件代码

### [git-worktree-runner](https://github.com/coderabbitai/git-worktree-runner)

gtr (Git Worktree Runner) 是一个用于简化 Git worktree 管理的跨平台命令行工具，它通过提供直观的命令、编辑器集成、AI 工具支持和自动化配置，极大地提升了并行开发工作流的效率。

- 🚀 **简化命令** - 使用 `git gtr new <branch>` 等直观命令创建和管理 worktree，告别冗长的原生 Git worktree 命令。
- 📁 **仓库作用域** - 每个 Git 仓库都拥有自己独立且互不干扰的 worktree 集合。
- 🔧 **配置优于标志** - 通过 `git gtr config` 一次性设置默认编辑器、AI 工具、文件复制规则等，后续使用简单命令即可。
- 🎨 **编辑器集成** - 支持一键在 Cursor、VS Code、Zed 等编辑器中打开指定 worktree。
- 🤖 **AI 工具支持** - 集成 Aider、Claude Code、OpenCode 等主流 AI 编程工具，可在特定 worktree 中启动。
- 📋 **智能文件复制** - 通过配置模式，自动将如 `.env.example`、`CLAUDE.md` 等配置文件复制到新 worktree，并可排除敏感文件。
- 📁 **目录复制加速** - 支持复制 `node_modules`、`.venv` 等依赖目录，避免重复安装，大幅缩短 worktree 创建时间。
- 🪝 **钩子系统** - 支持在 worktree 创建或删除后自动运行自定义命令（如 `npm install`、`cargo build`）。
- 🌍 **跨平台支持** - 兼容 macOS、Linux 和 Windows (通过 Git Bash 或 WSL)。
- ⚡ **并行开发** - 核心价值在于允许同时在不同 worktree 中处理多个分支（如功能开发、Bug 修复、PR 审查），而无需切换或储藏更改。
- 🛠️ **高级用法** - 支持通过 `--force` 和 `--name` 在同一分支上创建多个 worktree，便于多 AI 代理并行处理同一特性的不同部分。

### [Ademking/use-nemo：自定义React指令集](https://github.com/Ademking/use-nemo)

这是一个名为 use-nemo 的 Vite 插件库，允许开发者在 React 项目中创建自定义指令，实现代码转换和功能注入。

- 🐟 支持创建任意自定义指令（如 "use nemo"、"use cat" 等）
- ⚡ 基于 Vite 构建工具，通过插件机制实现代码转换
- 🔧 提供完整的 API 接口和辅助函数（injectCode、injectComment、injectImport）
- 📁 采用模块化设计，通过指令注册表管理自定义指令
- 🐱 内置 useMeow 示例指令，展示基本使用方法
- 📚 支持 TypeScript 类型定义，确保开发体验
- 🔄 指令处理流程包括发现、解析、转换和清理四个阶段

### [Acetyld/expo-foreground-actions：在用户切换应用后的宽限期内持续运行操作的启动功能](https://github.com/Acetyld/expo-foreground-actions)

该库允许应用在用户切换到其他应用后的宽限期内继续执行前台任务，适用于发送消息、创建任务或同步数据等场景。

- 📱 支持 iOS 和 Android 平台，模拟系统原生后台任务执行机制
- ⏱️ iOS 任务可运行约 30 秒，Android 前台服务运行时间更长但建议控制在 30 秒内
- 🚫 不适用于后台位置追踪，推荐使用 WorkManager 等替代方案
- 🔔 Android 支持自定义通知标题、描述和进度条，兼容 Android 34+ 后台策略
- ⚠️ iOS 支持后台执行时间即将到期时的通知提醒
- 🌐 提供有限的 Web 支持，建议使用 runInJS 方法
- 🔧 提供多种控制方法：启动/停止前台任务、强制终止所有任务、更新任务设置等
- 📊 可获取任务标识符、已运行任务计数和剩余后台执行时间
- 🛠️ 需要 Expo v49+ 环境，支持 Bare/Manage 工作流但不兼容 Expo Go

### [WookieFPV/expo-build-disk-cache：Expo CLI 应用构建缓存（使用磁盘）](https://github.com/WookieFPV/expo-build-disk-cache)

这是一个用于 Expo CLI 的本地磁盘构建缓存工具，通过缓存构建结果大幅提升 Android 和 iOS 应用的构建速度。

- ⚡ 显著加速 Expo 应用的 Android 和 iOS 构建过程
- 💾 利用本地磁盘缓存技术，跳过重复编译步骤
- 🚀 当缓存可用时，构建几乎可以立即启动
- 📋 要求 Expo SDK 53 及以上版本
- 🔧 支持自定义缓存目录和自动清理功能
- 🌐 可集成远程缓存提供商如 EAS
- 📄 采用 MIT 开源许可证
- ⭐ 获得 102 个星标，显示社区高度关注

### [css-extras](https://github.com/sindresorhus/css-extras)

`css-extras` 是一个利用原生 CSS `@function` 规则的实用自定义函数集合，无需构建步骤，可直接复制使用。它提供了数学运算、颜色处理、版式控制、布局、间距、动画等多种功能，但目前仅支持 Chrome 141+ 浏览器。

- 📦 无需构建步骤，可直接复制使用
- ⚠️ 目前仅支持 Chrome 141+ 浏览器
- 🔧 包含约 43 个 CSS 自定义函数
- 📐 涵盖数学计算、颜色处理、版式控制等类别
- 🎨 支持主题感知组件和响应式设计
- 💡 提供完整的函数参考和实际使用示例
- 📄 采用 MIT 或 CC0-1.0 开源协议

### [Mole](https://github.com/tw93/Mole)

Mole 是一款终端基础的 macOS 清理与优化工具，能够深度清理系统垃圾、彻底卸载应用、优化系统性能并分析磁盘空间。它通过命令行交互提供高效、轻量的操作体验，适合追求系统清理和性能提升的高级用户。

- 🕳️ **深度系统清理** – 清理远超 CleanMyMac 或 Lemon 的垃圾文件，包括缓存、日志和临时文件，可释放大量磁盘空间。
- 🗑️ **彻底应用卸载** – 扫描 22 个以上位置，移除应用残留文件，而不仅仅是删除 .app 文件。
- ⚙️ **系统性能优化** – 一键重建缓存、重置服务并清理交换文件和网络冗余，提升系统运行效率。
- 📊 **交互式磁盘分析** – 使用方向键导航文件夹，快速查找并删除大文件，直观展示磁盘使用情况。
- ⚡️ **快速轻量** – 基于终端设计，支持箭头键导航、分页显示及 Touch ID 授权，操作流畅便捷。
- 🛡️ **安全预览** – 可通过 `mo clean --dry-run` 预览清理内容，使用白名单功能保护特定缓存，确保操作安全。
- 🔧 **便捷安装与使用** – 支持 curl 脚本或 Homebrew 安装，提供多种命令如清理、卸载、优化和分析，还可配置 Raycast 或 Alfred 快速启动。
- 📘 **社区支持与开源** – 采用 MIT 许可证，欢迎用户参与改进和分享，共同推动工具发展。

### [Go to next change](https://marketplace.visualstudio.com/items?itemName=alfredbirk.go-to-next-change)

一款用于在代码变更中快速导航的扩展工具，其核心功能是通过快捷键在文件修改记录间循环跳转，并支持撤销操作与视图模式适配。

- 🔄 使用快捷键在文件变更差异间循环跳转：到达文件末尾时自动跳至下一个文件
- ⏭️ 跳转到下一个 Git 变更：Alt+Z（Windows）/ Opt+Z（Mac）
- ⏮️ 跳转到上一个 Git 变更：Alt+A（Windows）/ Opt+A（Mac）
- ↩️ 撤销选定变更并保存文件：Alt+Q（Windows）/ Opt+Q（Mac）
- 📂 跳转到下一个变更文件：Ctrl+Alt+Z / Cmd+Opt+Z
- 📁 跳转到上一个变更文件：Ctrl+Alt+A / Cmd+Opt+A
- 🌳 树形视图适配：在源代码管理中使用树形视图时，需在设置中启用「Go to next change: Tree view」确保正确跳转顺序
- 🐛 问题反馈：相关建议和问题可提交至 GitHub 仓库处理

### [3ru/eslint-plugin-baseline-js：✅ 用于强制执行 JavaScript 基线的 ESLint 插件](https://github.com/3ru/eslint-plugin-baseline-js)

这是一个用于强制执行 JavaScript Baseline 标准的 ESLint 插件，通过单一规则检测 JavaScript 特性兼容性

- 🚀 支持三种检测级别：广泛可用特性 (widely)、新特性 (newly) 和基于年份的基准
- ⚙️ 提供预设配置，支持 TypeScript 类型感知检查
- 🔧 可忽略特定特性或节点类型，支持渐进式采用
- 📊 基于 web-features 数据源，覆盖 JavaScript 语言特性
- 📈 生成覆盖率报告，展示特性映射状态
- 🔗 与 HTML/CSS Baseline 插件配合使用效果最佳
- 📄 采用 MIT 开源协议，项目处于预发布阶段

### [darkresearch/streamdown-rn：Vercel streamdown 的 React Native 版本，专为移动端 AI 驱动流媒体设计。](https://github.com/darkresearch/streamdown-rn)

这是一个基于 Vercel Streamdown 的 React Native 流式 Markdown 渲染器，专为移动端 AI 流式响应设计，支持动态组件注入和渐进式渲染。

- 🚀 **移动端优先** - 专为 React Native 构建，支持 iOS/Android/Web 三端，采用 StyleSheet 主题系统
- 🎯 **动态组件注入** - 核心创新功能，允许 AI 通过外部注册表注入任意 React Native 组件到 Markdown 中
- 🔄 **渐进式渲染** - 组件字段级骨架屏，感知性能提升 75%，支持流式数据逐字段显示
- 📱 **流式优化** - 智能处理不完整 Markdown，实时渲染 AI 响应，支持快速文本更新
- 🎨 **主题定制** - 内置深浅主题，支持深度样式覆盖和自定义主题配置
- 💻 **语法高亮** - 美观代码块支持复制到剪贴板，表格自动水平滚动
- ⚡ **性能优化** - 记忆化处理、组件缓存、智能 JSON 解析，优化长会话内存管理
- 🔧 **组件注册** - 支持 JSON Schema 验证、组件描述和渲染元数据定义
- 📦 **紧凑语法** - 使用短键名 (c/p) 和短属性名，提升流式传输效率和 LLM 性能
- 🛠️ **开发工具** - 提供 Markdown 处理、组件提取、验证统计等实用工具函数

## 更新

### [Ant Design 6.0](https://github.com/ant-design/ant-design/issues/55805)

Ant Design v6 正式发布，重点进行技术深度优化，提升对 React 18+ 的兼容性与性能，采用纯 CSS Variables 样式架构，全面实现组件语义化结构，并移除旧版废弃 API。本次升级支持平滑迁移，无需额外工具即可从 v5 直接升级，同时推出新组件与功能增强，如瀑布流、拖拽抽屉等，未来将聚焦移动端体验与无障碍支持。

- 🚀 **开源成就**：Ant Design 累计收获 96.6K Star、2314 位贡献者，社区活跃推动项目持续进化。
- 🎯 **技术升级**：最低支持 React 18，默认启用 React Compiler，彻底移除 IE 兼容，提升性能与兼容性。
- 🎨 **样式革新**：采用纯 CSS Variables 架构，支持零运行时样式生成与多主题切换，降低打包体积。
- 🧩 **语义化结构**：全量组件完成 DOM 语义化改造，支持逻辑位置描述与动态样式配置。
- 🗑️ **API 清理**：移除 v4 废弃 API，统一命名风格，保留 v5 兼容性。
- 🔥 **新组件功能**：新增 Masonry 瀑布流、Tooltip 平移滑动、InputNumber spinner 模式、Drawer 拖拽及蒙版模糊背景。
- 📋 **升级指南**：v5 项目可直接升级至 v6，需运行在 React 18+ 环境并替换废弃 API。
- 🌟 **未来计划**：优化移动端交互、增强无障碍支持，跟进 React 新特性并开发新组件。
- 🤖 **生态扩展**：Ant Design X 2.0 同步发布，强化 AI 场景交互与渲染能力。

### [工具集 | Node.js v25.2.1 文档](https://nodejs.org/docs/latest/api/util.html#utildeprecatefn-msg-code-options)

Node.js v25.2.1 实用工具模块文档，提供用于调试和内部 API 支持的多种功能方法。

- 🔄 **util.callbackify()** - 将异步函数转换为回调风格函数
- 🐛 **util.debuglog()** - 创建条件性调试日志函数
- ⚠️ **util.deprecate()** - 标记函数为已弃用并发出警告
- 🔍 **util.inspect()** - 返回对象的字符串表示，用于调试
- 📊 **util.format()** - 使用格式说明符返回格式化字符串
- 🧩 **util.types** - 提供各种内置对象的类型检查
- 🔄 **util.promisify()** - 将回调风格函数转换为 Promise 版本
- 📝 **util.parseArgs()** - 高级命令行参数解析 API
- 🔤 **util.TextDecoder/TextEncoder** - WHATWG 编码标准实现
- 🎨 **util.styleText()** - 终端文本格式化功能
- 🛑 **util.aborted()** - 监听中止信号并返回 Promise
- 📧 **util.MIMEType/MIMEParams** - MIME 类型解析和操作类

### [Promise 子类的新`use()`文档 · reactwg/async-react · 讨论 #3 · GitHub](https://github.com/reactwg/async-react/discussions/3)

React 工作组发布了关于 Promise 子类的新文档，主要说明在数据获取层中如何正确创建用于 use() 的 Promise 对象。

- 📚 新增 Promise 子类的 use() 文档，说明创建悬停 Promise 的细节
- ⚠️ 不建议条件性调用 use()，可能导致数据错乱和优化失效
- 🔄 用户代码中的条件性 use() 调用仍被允许
- 📝 推荐通过子类化 Promise 或设置状态字段来同步获取已解析数据
- 🛠️ 文档由多位贡献者共同完善，欢迎反馈和提问

### [ESLint v10.0.0-alpha.0 发布 - ESLint - 可插拔 JavaScript 代码检查工具](https://eslint.org/blog/2025/11/eslint-v10.0.0-alpha.0-released/)

ESLint v10.0.0-alpha.0 作为主要版本发布，包含新功能、错误修复和多项重大变更，目前为预发布版本仅供测试反馈。

- 🚨 此为预发布版本，不建议用于生产环境，需通过指定标签安装
- 🔄 不再支持 Node.js v20.19.0 以下版本及 v21/v23，仅支持 v20.19.0+、v22.13.0+ 和 v24+
- 📁 配置文件查找逻辑更新，改为从被检测文件目录开始查找 eslint.config.\*
- 🗑️ 完全移除 eslintrc 配置系统及相关环境变量、CLI 参数和文件支持
- ⚠️ 停止支持 jiti < v2.2.0 版本
- 📋 更新 eslint:recommended 配置，纳入新的重要规则
- 🔧 移除多个已弃用的 rule context 成员，需使用替代属性
- 🧪 删除 LintMessage#nodeType 和 TestCaseError#type 属性
- 🌐 Program AST 节点范围调整为覆盖整个源代码文本
- 🔭 要求自定义 ScopeManager 实现自动解析全局变量引用
- 📚 提供详细迁移指南协助升级适配

### [Prisma 7 发布：无锈、更快速、兼容性更强](https://www.prisma.io/blog/announcing-prisma-orm-7-0-0)

Prisma ORM 和 Prisma Postgres 发布第 7 版重大更新，聚焦性能优化与开发者体验提升

- 🚀 客户端从 Rust 迁移至 TypeScript，实现 90% 体积缩减与 3 倍查询加速
- 🛠️ 生成代码移至项目源码目录，提升开发工具链兼容性
- ⚡ 与 ArkType 合作优化类型系统，类型检查速度提升 70%
- 🗄️ Prisma Postgres 支持标准连接协议，兼容第三方工具
- 🔧 新增动态配置文件，支持环境变量注入配置
- 🌟 内置枚举映射支持，最低 Node/TypeScript 版本要求更新
- 📦 简化边缘计算平台部署，完美支持 Cloudflare Workers
- 🎯 采用裸机微虚拟机架构，数据库性能大幅优化
- ✨ 提供单命令行快速创建数据库，集成 AI 工作流支持
- 📋 推出全新 Prisma Studio，完整迁移指南已同步发布

### [发布 streamdown@1.5.0 · vercel/streamdown](https://github.com/vercel/streamdown/releases/tag/streamdown%401.5.0)

Streamdown 项目发布了 1.5.0 版本更新，主要优化了功能体验并修复了多项问题。

- 🚀 新增 Mermaid 图表全屏查看功能
- ⚡ 修复大型代码流传输块的性能问题
- 🌏 增强中日韩语言支持
- 🖼️ 修复 Base64 图像显示问题
- 📊 为表格添加 TSV 格式复制支持
- 🎨 新增区块级自定义钩子
- 📚 完善文档和样式说明
- 🔧 修复代码块边框和溢出显示问题
- 📦 动态加载 KaTeX 样式以优化性能
- 🛠️ 导出不完整 Markdown 解析函数至公共 API

### [Storybook MCP 抢先预览](https://storybook.js.org/blog/storybook-mcp-sneak-peek/)

Storybook MCP 通过提供机器可读的组件上下文和自主纠错循环，帮助 AI 编程代理生成更符合团队标准的代码，减少错误并提升开发效率。

- 📚 利用现有 Storybook 资源为 AI 提供组件模式、文档和测试用例
- 🤖 解决 AI 生成代码质量差、难以合并的问题
- ⚡ 基准测试显示能更快生成代码且使用更少 token
- 🔧 包含自主纠错功能，可运行组件测试并自动修复错误
- 🎯 早期访问计划面向拥有成熟 React 设计系统的团队
- 📅 计划于 2025 年 12 月 2 日启动早期访问，名额有限

### [[next-upgrade] 由 eps1lon 添加 `next upgrade` 功能 · Pull Request #86120 · vercel/next.js · GitHub](https://github.com/vercel/next.js/pull/86120)

Next.js 项目新增了 `next upgrade` 命令，用于便捷升级 Next.js 版本，该功能通过调用 `@next/codemod` 的升级工具实现，并优化了包管理器的执行命令以减少冗余输出。

- 🆕 新增 `next upgrade` CLI 命令，作为 `@next/codemod@canary upgrade` 的便捷别名
- 🔧 支持通过包管理器（如 pnpm、yarn）调用，例如 `pnpm next upgrade` 对应 `pnpm --quiet dlx @next/codemod@canary upgrade latest`
- 🚀 默认使用 Codemod 的 canary 版本进行升级，视为稳定版本
- 📝 更新了 CLI 文档，包含命令参数说明和用法示例
- ⚡ 优化了 npx 命令执行，添加 `--yes` 标志避免 npm 的误输入提示
- 🔇 为 pnpm 和 yarn 添加静默模式（`--silent`/`--quiet`），减少包管理器日志干扰
- 🧪 包含完整的测试计划验证功能可靠性
- 📊 代码合并后显示构建大小和性能指标变化，部分客户端包略有增加

## AI

### [VSCODE 2025 年 10 月（版本 1.106）](https://code.visualstudio.com/updates/v1_106)

VS Code 2025 年 10 月版本 (1.106) 带来三大核心更新：集中管理 AI 代理会话的 Agent HQ、增强安全控制机制，以及优化日常编码体验的编辑器改进。

- 🎯 **Agent HQ 统一视图** - 新增代理会话中心，支持本地与云端 AI 代理的集中监控和管理
- 🛡️ **安全与信任增强** - 引入工具后审批机制，支持按来源批量信任 MCP 服务器
- ✨ **编辑器体验优化** - 差异编辑器支持删除文本选择，Go to Line 命令新增字符定位功能
- 🤖 **计划代理功能** - 新增分步任务规划代理，支持自定义规划流程
- 🌐 **云端代理集成** - Copilot 编码代理集成至 Chat 扩展，提供更原生体验
- 🔄 **自定义代理升级** - 聊天模式重命名为自定义代理，支持跨环境运行配置
- 📝 **代码编辑改进** - 内联建议开源合并，支持通过装订区图标暂停建议
- 🎨 **界面视觉刷新** - 更新 codicon 图标集，采用更现代的曲线设计
- ⚙️ **高级设置支持** - 新增高级设置分类，专为需要精细控制的用户设计
- 💬 **聊天功能增强** - 改进工具选择算法，支持保存对话为可重用提示
- 🔧 **终端智能感知** - 终端 IntelliSense 结束预览阶段，正式向所有用户推出
- 📊 **测试覆盖导航** - 新增未覆盖代码行导航命令，便于快速定位测试缺口
- 🔐 **认证管理优化** - 扩展账户偏好设置更易发现，微软认证淘汰经典模式

### [双子座 3](https://blog.google/products/gemini/gemini-3-collection/)

Gemini 3 作为谷歌最智能的 AI 模型正式发布，整合了多模态理解、长上下文处理、思维推理与原生工具使用等能力，旨在帮助用户实现各类创意构想。该模型已全面应用于 Gemini 应用、谷歌搜索、企业服务及开发者平台。

- 🚀 Gemini 3 成为谷歌最智能的集成化 AI 模型，融合多模态与推理能力
- 📱 Gemini 应用迎来重大升级，搭载 Gemini 3 增强智能功能
- 🔍 谷歌搜索集成 Gemini 3，提供更智能的搜索与 AI 模式
- 💻 开发者可通过 Gemini 3 体验智能编码与 Antigravity 开发平台
- 🏢 企业用户可通过 Gemini Enterprise 和 Vertex AI 使用 Gemini 3
- 🎨 生成式 UI 技术在 Gemini 应用中实现可视化交互体验
- ⚙️ Gemini CLI 与 Android Studio 集成 Gemini 3 Pro 助力开发效率
- 🔥 Flutter 平台推出 GenUI SDK，支持生成式界面开发

## 其他

### [中级开发工程师](https://dawranliou.com/blog/intermediate-dev/)

一位中级软件开发者分享了他的工作哲学与成长历程，强调代码质量、团队协作与持续学习的重要性。他注重代码的可读性与可维护性，积极通过文档和可视化工具提升沟通效率，并主动支持团队与跨部门协作，同时从开源社区汲取灵感。

- 💻 **关注代码质量**：权衡代码实现方式，注重可读性、可维护性与未来扩展性，兼顾主观审美
- 📖 **优化提交记录**：精心整理 Git 历史，通过拆分、重组提交使代码评审更清晰，辅以图表动画提升沟通效率
- 🔍 **深入理解代码**：通过阅读源码、技术文档与 Git 历史追溯代码背景，避免武断否定遗留代码
- 📝 **记录知识沉淀**：在技术文档、提交信息、代码注释中阐释“为何如此实现”，而不仅描述“代码功能”
- 🛠️ **掌握全栈技能**：从前端到 DevOps 工具链，从数据库优化到编译器排查，主动拓展技术边界
- ✅ **测试驱动开发**：以测试明确目标，通过测试案例讲述比文档更直观的代码故事
- 🤝 **助力团队成功**：代码评审以理解与学习为目的，避免吹毛求疵，注重知识传递与协作解困
- 🧭 **引导新人融入**：分享开发环境配置、工作流技巧与沉淀的团队经验
- 🌐 **支持跨部门协作**：协助设计师与测试工程师完善产品细节，参与运维工具链问题排查
- 🚀 **拥抱开源社区**：从 Common Lisp、Fennel 等语言生态汲取灵感，反哺项目与技术讨论
- 🌱 **十年成长感悟**：认为编程本质是人际沟通，开发者需兼顾文档、协作与问题拆解能力，感念 Clojure 与团队助其突破瓶颈

---

既然 AI 可以按需提供你的代码所需的特定功能，为什么还要增加额外的供应链风险，引入另一个依赖项呢？

因此，小型的、低价值的依赖项在未来会消失。

-- 《"小型"开源软件的命运》

---

去年，互联网上机器人流量第一次超过了人类流量。根据一份报告，自动化系统在 2024 年占所有网络流量的 51%，而且 AI 生成的文章数量也在 2024 年底首次超过了人类撰写的文章。

-- 《互联网已死》

---

如何把个体的 AI 能力放大为团队能力？第一步是什么？

其实比较难，因为这个很取决个人本身，好比最开始 ChatGPT 刚刚出来的时候，愿意折腾的同学很早就去折腾了
第一步还是建议对于好的标准，什么是用的好，是怎么用的，对清楚团队的要求，以及更多还是通过项目事情去锻炼人，先有场景，然后有标准 SOP，最后就是把整个团队的信息总线给建立好，形成一个非常通顺的上下文环境，方便大家可以很好的接入，没有阻碍

如果用你自己的话来定义「10x 组织」，你会怎么说？

事情传递效率非常高，理解非常快，Get 很快，没有消息传递失真
上层决策非常清晰，保障一线执行非常顺畅，决策基于统一上下文环境
一线非常善于使用各种工具来解决问题，不设置自己岗位限制
