---
title: 2025-第二十八周
date: '2025-07-08'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [管理你的 Promises 状态](https://spin.atomicobject.com/managing-the-state-of-your-promises/)

本文介绍了 JavaScript 中`Promise.all`和`Promise.allSettled`的用法及区别，重点讨论了如何在并行执行多个 Promise 时灵活处理成功和失败的情况，而无需依赖复杂的状态管理工具。

- 🔄 **`Promise.all`的局限性**

  - 并行执行多个 Promise，但任一失败会立即拒绝，并返回第一个错误。
  - 适用于所有 Promise 必须成功才能继续的场景。

- ✅ **`Promise.allSettled`的优势**

  - 无论 Promise 成功或失败，都会返回所有结果的状态（`fulfilled`或`rejected`）。
  - 提供更灵活的错误处理，适合需要独立跟踪每个 Promise 结果的场景。

- 🛠️ **使用示例对比**

  - `Promise.all`：快速失败，适合严格依赖所有成功的操作（如批量请求）。
  - `Promise.allSettled`：返回全部状态，适合部分失败不影响整体的任务（如混合成功/失败的异步操作）。

- 💡 **实际应用场景**

  - 结合两种方法，可同时处理需严格成功和容忍失败的任务，并在最终统一检查结果（如多步骤异步流程的汇总）。

- 🎯 **核心价值**
  - 通过原生 Promise 方法简化异步状态管理，避免引入冗余的全局状态工具。

### [现代 JavaScript 在 NGINX 中的应用：njs 对 QuickJS 引擎的支持——NGINX 社区博客](https://blog.nginx.org/blog/quickjs-engine-support-for-njs)

NGINX 的 JavaScript 模块（njs）现在支持 QuickJS 引擎，提供 ES2023 兼容性，为开发者带来更多现代 JavaScript 特性。

- 🚀 **QuickJS 引擎支持**：njs 0.9.1 版本引入 QuickJS 引擎，支持完整的 ES2023 特性，包括模块、异步生成器、代理和 BigInt 等。
- ⚖️ **平衡性能与兼容性**：QuickJS 在复杂脚本和长期运行任务中表现优异，但创建新上下文的速度较慢，需权衡性能与内存使用。
- 🔧 **配置简单**：通过`js_engine`指令可轻松切换引擎，支持全局或按服务器配置，默认仍为 njs 引擎以确保向后兼容。
- 📊 **性能优化**：通过`js_context_reuse`指令优化上下文重用，默认 128 个上下文池，显著提升性能，接近 njs 引擎水平。
- 🔮 **未来规划**：计划逐步将 QuickJS 设为默认引擎，鼓励开发者迁移并使用现代 JavaScript 特性，同时继续优化两者兼容性。
- 📝 **迁移建议**：建议开发者测试 QuickJS，逐步迁移新代码，利用其现代特性，并通过 GitHub 反馈使用体验。

### [什么是 popover=hint?](https://una.im/popover-hint/)

HTML 新特性 `popover="hint"` 和实验性 API `interestfor` 的引入，旨在简化分层 UI 元素的实现，提供更灵活的用户交互方式。

- 🆕 **新特性介绍**：`popover="hint"` 允许在不关闭其他弹出层的情况下显示提示内容，适用于工具提示或链接预览等场景。
- 🔍 **三种弹出类型对比**：`auto`、`manual` 和 `hint` 在轻触关闭、焦点管理等行为上各有不同。
- 🛠️ **实现示例**：通过 JavaScript 监听鼠标悬停和键盘事件，实现 `hint` 弹出层的动态控制。
- ⚡ **实验性 API**：`interestfor` 支持通过悬停或聚焦触发弹出层，无需依赖按钮点击，且适用于链接等元素。

## 工具

### [foresightjs](https://foresightjs.com/)

通过智能预取技术（如鼠标轨迹预测、键盘导航和滚动预测）提升应用导航速度，优化性能，并提供简单快速的集成方式。

- 🚀 **鼠标轨迹预测**  
  通过分析鼠标移动方向预取页面和数据，使用户导航体验瞬间完成。

- ⌨️ **键盘导航支持**  
  在用户通过键盘切换链接时预取内容，确保键盘用户与鼠标用户同样享受极速体验。

- 🖱️ **滚动预测**  
  根据用户滚动方向预取视口附近的内容，快速加载即将出现的链接。

- ⚡ **性能优化**  
  采用观察者模式、最小化 DOM 查询和缓存技术，避免布局抖动和不必要的计算，确保高效运行。

- 📱 **设备兼容性提示**  
  交互式演示仅支持桌面设备（需鼠标和键盘），移动端可阅读文档但无法完整体验功能。

- 🛠️ **开发工具与调试**  
  提供实时调试工具，支持可视化反馈和参数调整，帮助开发者优化预取效果。

- ⏱️ **快速集成**  
  5 分钟内即可实现用户意图预测，无需复杂配置，支持 TypeScript 和主流框架（如 Next.js、React Router）。

- 📄 **完整文档与配置**  
  提供详细文档和预置框架集成方案，满足多样化开发需求。

### [xnx3/translate: AI 国际化，两行 JS 实现 HTML 自动翻译。无需改动页面，无语言配置文件，无需 API 密钥，SEO 友好！](https://github.com/xnx3/translate)

AI i18n，两行 js 实现 html 全自动翻译。无需改动页面、无语言配置文件、无 API Key、对 SEO 友好。

- 🌟 **简单易用**：仅需引入几行 JavaScript 代码即可实现上百种语言切换能力。
- 🚀 **无需额外工作**：无需修改页面或配置语言文件，自动扫描 DOM 并翻译。
- 🔧 **高度灵活**：支持指定翻译区域、自定义术语、忽略特定元素等扩展功能。
- 🌍 **自动语种切换**：根据用户语言偏好或国家自动切换显示语言。
- ⚡ **极速翻译**：内置三层缓存和预加载机制，毫秒级响应。
- 🆓 **永久免费**：采用 MIT 开源协议，支持商业用途无需付费。
- 🔍 **SEO 友好**：不影响搜索引擎收录，翻译后页面也可被收录（高级版本支持）。
- 🏢 **私有部署**：支持政府或企业内网环境下的私有化部署。
- 🌐 **全球节点**：自动选择延迟最低的全球网络节点，确保高效稳定。
- 📜 **HTML 整体翻译**：支持传入 HTML 源码并返回翻译后的结果，兼容复杂代码。
- 🖥️ **浏览器插件**：提供全套浏览器翻译插件方案，可二次开发盈利。
- 🛠️ **丰富指令**：支持默认语种设置、术语自定义、动态内容监控等微调功能。
- 📱 **框架兼容**：适配 Vue、React 等动态渲染内容，实时翻译 DOM 变动。
- � **在线体验**：通过注入代码即可在任意网页测试翻译效果。
- 📦 **NPM 支持**：提供`i18n-jsautotranslate`包，便于项目集成。

### [jsonrepair](https://github.com/josdejong/jsonrepair)

修复无效的 JSON

### [magnitude](https://github.com/magnitudedev/magnitude)

Magnitude 是一款基于视觉 AI 的先进浏览器自动化工具，支持自然语言控制，适用于任务自动化、数据提取和网页测试等场景。

- 🚀 **高性能** - 在 WebVoyager 评测中得分高达 94%，采用视觉优先架构，突破传统 DOM 依赖
- 🧭 **智能导航** - 理解任意界面并规划操作路径，支持像素级精准交互
- 🤖 **多层级控制** - 既可执行高层任务（如“创建任务”），也能处理底层动作（如拖拽排序）
- 📊 **结构化提取** - 通过 Zod 模式智能提取数据，支持动态生成字段（如任务难度评分）
- ✅ **内置测试** - 提供可视化断言测试运行器，支持 CI/CD 集成
- 🔧 **快速上手** - 通过`npx create-magnitude-app`一键生成示例项目，或`npm i`集成测试环境
- 🌐 **跨平台潜力** - 架构兼容未来桌面应用/虚拟机，支持 Claude Sonnet 4 等大模型
- 💡 **解决痛点** - 突破传统代理的 DOM 依赖问题，提供可重复的确定性自动化方案

### [antd-zod](https://github.com/MrBr/antd-zod)

一个关于 antd-zod 库的文档，该库旨在实现 Zod 验证与 Antd 表单字段的无缝集成。

### [document](https://github.com/ranuts/document)

基于 OnlyOffice 的本地网页版文档编辑器，支持在浏览器中直接编辑文档，无需服务器处理，确保隐私与安全。项目提供多格式支持、实时编辑、纯前端架构等核心功能，并详细说明了使用方法、技术架构、部署及开发指南。

## 更新

### [选择性服务端渲染（SSR）| TanStack Start React 文档](https://tanstack.com/start/latest/docs/framework/react/selective-ssr)

TanStack Start 框架提供了选择性 SSR（服务器端渲染）功能，允许开发者根据需求灵活配置路由的服务器端行为。

- 🚀 **选择性 SSR 概述**  
  默认情况下，初始请求的路由会在服务器端执行`beforeLoad`和`loader`，并渲染组件生成 HTML 发送到客户端。但可通过配置禁用 SSR 或部分功能。

- ⚙️ **配置选项**

  - `ssr: true`：默认模式，服务器端执行所有逻辑并渲染组件。
  - `ssr: false`：完全禁用服务器端逻辑和渲染，仅在客户端执行。
  - `ssr: 'data-only'`：服务器端执行数据逻辑，但组件渲染在客户端完成。

- 🔧 **动态配置**  
  支持通过函数动态决定 SSR 行为，例如根据参数或搜索条件返回`false`或`'data-only'`。

- 🧬 **继承规则**  
  子路由继承父路由的 SSR 配置，但只能更严格（例如从`true`改为`'data-only'`或`false`）。

- ⏳ **回退渲染**  
  对于禁用 SSR 的路由，服务器会渲染`pendingComponent`作为占位，客户端 hydration 时至少显示`minPendingMs`时间。

- 🔄 **与 SPA 模式对比**  
  SPA 模式完全禁用服务器端逻辑和渲染，而选择性 SSR 允许按路由精细控制。

### [功能：由 nebrelbug 生成路由类型清单 · Pull Request #81396 · vercel/next.js · GitHub](https://github.com/vercel/next.js/pull/81396)

Next.js 项目中新增了一个功能，用于生成路由类型清单，以简化 App Router 组件的类型定义。

- 🚀 **功能概述**：生成 `.next/types/routes.ts` 文件，提供全局的 `PageProps` 和 `LayoutProps` 类型，无需手动导入。
- 📂 **路由清单结构**：包含 `appRoutes`、`layoutRoutes` 和 `pageRoutes`，分别对应应用路由、布局路由和页面路由的路径配置。
- 💡 **使用示例**：
  - 页面组件可直接使用 `PageProps`，如 `props: PageProps<'/blog/[slug]'>`。
  - 布局组件可使用 `LayoutProps`，并自动支持并行路由的插槽类型。
- ✅ **主要优势**：
  - 零导入：类型全局可用。
  - 路由验证：TypeScript 确保路由路径有效。
  - 自动补全：IDE 提示可用路由。
  - 并行路由：布局插槽自动类型化。
- ⚙️ **实验性功能**：通过 `config.experimental.newTypedRoutes` 标志启用（当前为 Canary 版本功能）。
- 🔄 **开发动态**：
  - PR #81396 由 `nebrelbug` 提交，合并了 10 个提交到 `canary` 分支。
  - 包含性能优化、类型生成改进和测试用例添加。
- ❓ **待解决问题**：讨论是否复用旧版实验性标志，以及路径处理中的潜在冲突（如 `%5F` 转义）。

## AI

### [Kimi-K2](https://github.com/MoonshotAI/Kimi-K2)

Kimi K2，一款先进的混合专家（MoE）语言模型，具有 1 万亿总参数和 320 亿激活参数。该模型采用 Muon 优化器训练，在知识、推理和编程任务中表现卓越，并针对智能代理能力进行了优化。文章详细介绍了模型架构、评估结果、部署方式及使用方法，并提供了 API 访问和开源许可信息。

### [xmcp](https://github.com/basementstudio/xmcp)

xmcp 是一个基于 TypeScript 的框架，专为构建和部署 MCP（Model Context Protocol）应用程序而设计。它注重开发者体验（DX），简化开发流程，并支持灵活部署。以下是关键信息：

- 🚀 **框架简介** - xmcp 是一个 TypeScript 框架，用于构建和部署 MCP 应用程序，优化开发者体验。
- ⚡ **快速开始** - 通过 `npx create-xmcp-app@latest` 创建新项目，或通过 `npx init-xmcp@latest` 在现有 Next.js/Express 项目中初始化。
- 🔥 **核心功能**
  - 文件系统路由（自动注册工具目录）
  - 热重载（即时开发反馈）
  - 中间件支持（认证和自定义功能）
  - 可扩展配置（自定义 MCP 服务器）
  - 灵活部署（支持任意平台，包括 Vercel 开箱即用）。
- 📚 **学习资源** - 访问 [xmcp.dev](https://xmcp.dev) 了解项目，或查看 [文档](https://xmcp.dev/docs) 获取详细指南。

### [程序员的提示工程实战手册](https://baoyu.io/translations/the-prompt-engineering-playbook-for)

开发者正借助 AI 编程助手加速工作流程，但其输出质量高度依赖提示词设计。本文系统总结了优化提示的实践方法，涵盖调试、重构、功能实现等场景，并提炼出核心原则与常见反模式。

- 🎯 **明确目标与上下文**：提供清晰的编程语言、框架、预期行为及错误信息，避免模糊请求（如“代码不工作”）。
- 🔍 **结构化调试提示**：包含代码片段、错误日志、输入/输出示例，引导 AI 逐行分析（如“解释变量值变化”）。
- 🛠️ **分步重构指令**：指定优化方向（如性能、可读性），要求 AI 附带解释注释（如“用 Map 替代循环以提升查找效率”）。
- 🧩 **功能实现迭代法**：从高层需求拆解为子任务（如“先设计 API 调用，再处理状态管理”），逐步完善代码。
- 📌 **输入/输出示例**：通过具体用例约束 AI 输出（如“输入 `[3,1,4]` 应返回排序后的 `[1,3,4]`”）。
- 🎭 **角色扮演技巧**：设定 AI 身份（如“资深 React 审查员”）以提升回答专业性。
- ⚠️ **避免常见反模式**：如超载提示（一次性要求过多）、忽略 AI 澄清请求或风格不一致。
- 🔄 **迭代优化对话**：通过后续追问修正 AI 输出（如“改用迭代而非递归方案”）。

**示例对比**：

- ❌ 低效提示：“函数为什么不工作？” → 获得泛泛猜测。
- ✅ 高效提示：“函数预期返回数组总和，但输出 NaN。代码如下：[代码]。输入 `[1,2,3]` 时应返回 `6`，实际得到 NaN。原因是什么？” → AI 精准定位循环边界错误。

通过系统化提示设计，开发者可将 AI 转化为高效的“结对编程”伙伴，显著提升开发效率与代码质量。

## 其他

如果你把爱好当成职业，想以此养活自己，一段时间后，最初的兴奋消退了，你就会发现，开始阶段根本不算什么，真正的困难在后面，无数繁琐和重复的工作正等着你。

这个时刻被称为"放弃点"（quitting point），很多人会在这个时点选择放弃。

每个人的放弃点不一样，但都会到来。作家的放弃点，也许是小说写到第 30 页，最初的灵感枯竭，不知道怎么写下去。创业者的放弃点，也许是最初的几个月之后，市场的反应不像朋友和家人那样热烈。艺术家的放弃点，也许是作品第一次上架后，意识到自己的愿景与能力之间存在巨大差距。

-- 《眼光过高是一种自我破坏》
