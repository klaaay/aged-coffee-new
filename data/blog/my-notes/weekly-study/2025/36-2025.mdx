---
title: 2025-第三十六周
date: '2025-00-01'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [用 JavaScript Beacon 说再见 | Hemath 的博客](https://hemath.dev/blog/say-bye-with-javascript-beacon/)


本文介绍了在用户离开网页时向服务器发送数据的可靠方法，重点推荐使用 JavaScript 的 Beacon API 替代传统的 XMLHTTPRequest 方案。

- 🚫 传统 XMLHTTPRequest 在 beforeunload 事件中发送请求不可靠，可能被浏览器取消
- ⚡ 浏览器为避免用户体验延迟，不会等待 JavaScript 完全执行
- 📨 Beacon API 采用 fire-and-forget 机制，请求发送后立即结束执行
- 🎯 使用方法简单：navigator.sendBeacon(url, data)
- 📏 限制：仅支持 POST 请求且数据量较小
- 💡 适用场景：页面关闭时的数据分析、自动登出等
- 🔄 也可用于常规数据同步，如实时保存用户输入
- 📊 特别适合不需要等待响应的场景（如数据分析）

### [大规模自托管 Next.js 完整指南](https://dlhck.com/thoughts/the-complete-guide-to-self-hosting-nextjs-at-scale)

本文全面介绍了大规模自托管 Next.js 的生产环境部署挑战与解决方案，重点针对多副本水平扩展场景下的核心问题。

- 🐳 必须改造官方 Dockerfile：添加健康检查实现零停机部署，避免重启循环和僵尸容器
- 🌐 反向代理需禁用响应缓冲：配置 X-Accel-Buffering:no 确保 React Suspense 和流式响应正常工作
- 🧠 分布式缓存必须使用 Redis：替代本地文件缓存，解决多副本数据不一致问题
- 🖼️ 图像优化需外部处理：采用 ImageKit 或自托管 IPX 服务，避免重复处理造成的资源浪费
- 📦 CDN 必须遵循 Cache-Control：根据动态路由、认证状态等头部正确缓存内容
- 🔑 服务器动作需固定加密密钥：设置 NEXT_SERVER_ACTIONS_ENCRYPTION_KEY 避免部署版本不一致错误
- ⚠️ 注意 monorepo 陷阱：缓存处理器文件重复会导致连接失败，需使用绝对路径和 webpack 插件
- 📊 性能优化关键：监控 Redis 内存使用，控制缓存条目大小（建议 < 1MB），预处理数据再缓存
- 🔒 安全注意事项：服务器动作应视为公开 API 端点，必须实施身份验证和授权检查
- ✅ 生产清单：包含负载测试、副本健康监控、缓存命中率告警和回滚策略验证

## 工具

### [CR-Mentor](https://github.com/Gijela/CR-Mentor)

CR-Mentor 是一个基于 AI 和知识库的智能代码审查与开发者成长平台，旨在将代码审查转化为团队知识积累和个人提升的宝贵机会。

- 🧠 深度代码理解：集成 Deepwiki 技术，可自动追踪和分析代码变更相关的所有文件，实现全局视角的代码分析
- 📊 开发者画像：通过分析 GitHub 用户全部提交历史，自动生成包含技术优势、常见问题与成长曲线的个人能力画像
- 💾 知识库管理：提供 MCP 知识管理能力，支持一键保存审查中的亮点与最佳实践，形成可检索复用的团队知识资产
- ⚙️ 自定义规则：支持上传团队专属代码标准和文档，智能代理能自动识别潜在风险并提供专业建议
- 🚀 快速开始：项目采用多模块架构（前端、智能代理、Koa 后端），支持通过 pnpm 快速部署和体验

### [nstr](https://github.com/shuding/nstr)

该文章介绍了一个名为 nstr 的 JavaScript 库，它能自动检测并修复浮点数运算中出现的精度问题，从而避免在用户界面中显示不美观的小数点后多余的数字。

- 🧠 **智能精度检测**：自动识别并清理浮点数运算产生的精度误差（如 `0.1 + 0.2` 输出 `"0.3"`），同时保留用户有意输入的高精度数字。
- 🎯 **解决实际问题**：有效解决了 UI 开发中的常见痛点，例如 CSS 变换属性中的坐标值和价格显示中出现的长小数。
- 🛠️ **优于传统方案**：不同于 `toFixed()` 或 `toPrecision()` 需要预设精度，nstr 能自动为每个数字选择最佳精度。
- 📦 **易于安装使用**：通过 npm、pnpm 或 yarn 即可安装，使用简单，只需用 `nstr()` 函数包装任何数字即可。
- ⚙️ **可定制选项**：提供 `threshold`（检测敏感度）和 `maxDecimals`（最大保留小数位数）等高级选项以满足不同需求。
- 🔍 **工作原理**：通过将数字转换为固定小数位字符串，检测连续的 0 或 9 模式，并进行智能截断或舍入来清理结果。

### [fastmcp](https://github.com/punkpeye/fastmcp)

FastMCP 是一个基于 TypeScript 的框架，用于构建支持客户端会话的 MCP（Model Context Protocol）服务器。它简化了 MCP 服务器的开发流程，提供了丰富的功能，如工具、资源、提示词定义、身份验证、会话管理、多媒体内容处理等，并支持多种传输协议和部署模式。

- 🚀 **功能丰富**：支持工具、资源、提示词、身份验证、会话、图像/音频内容、嵌入式资源、日志记录、错误处理、HTTP 流式传输、无状态模式等。
- 📦 **易于使用**：提供简洁的 API，快速构建 MCP 服务器，无需处理底层实现细节。
- 🌐 **多传输支持**：支持 stdio、HTTP 流式传输和 SSE，适用于本地和远程部署。
- 🔒 **身份验证与授权**：支持会话身份验证和工具访问控制，确保安全性。
- 📡 **流式输出与进度通知**：工具支持流式输出和进度报告，提升用户体验。
- 🔧 **可定制日志与错误处理**：支持自定义日志记录器和用户友好的错误提示。
- 🧩 **资源与模板**：支持动态资源加载和模板，提供自动补全功能。
- 🤖 **提示词与自动补全**：支持提示词模板和参数自动补全，增强 LLM 交互。
- ⚡ **无状态模式**：支持无状态部署，适合服务器 less 环境和负载均衡。
- 📚 **生态与展示**：已有多个第三方项目基于 FastMCP 开发，社区活跃。

## 更新

## 设计

## AI

### [llms-txt-hub](https://github.com/thedaviddias/llms-txt-hub)

llms.txt 是一个用于标准化 LLM 工具和服务如何与项目文档及代码库交互的规范文件。该仓库作为中心枢纽，汇集了各类项目和平台对 llms.txt 的实现和资源。

- 🤖 **指导 AI 模型**：引导 AI 模型如何解释和使用项目文档。
- 📚 **标准化访问**：为 LLM 驱动的工具提供标准化的文档访问方式。
- 🔍 **提高准确性**：提升 AI 关于项目响应的准确性。
- 🛠 **增强体验**：通过 AI 工具改善开发者体验。
- 🔒 **设定边界**：为 AI 与内容的交互设定明确的界限。


### [iphone-mcp](https://github.com/Lakr233/iphone-mcp)

该文本介绍了一个基于 Model Context Protocol (MCP) 的服务端项目，用于通过 Appium 自动化控制 iPhone，支持应用操作、UI 交互和截图等功能。

- 📱 **项目简介**: 一个用于 iPhone 自动化的 MCP 服务器，通过 Appium 实现应用控制、UI 交互和可流式传输的 HTTP 截图。
- 📋 **主要功能**: 获取设备信息、列出已安装应用、捕获屏幕截图、列出 UI 元素、执行触摸操作、通过 Bundle ID 启动或切换应用，并提供优化的 XML 输出以减少 token 使用。
- ⚙️ **安装要求**: 需要 Python 3.8+、Node.js 和 npm、iPhone UDID、Xcode，并需安装 Appium 及配置 WebDriver Agent。
- 🚀 **使用方法**: 运行 `start.sh` 启动服务，默认通过 `http://127.0.0.1:8765/mcp` 访问，提供多种工具如获取设备信息、截图、点击、滑动、文本输入和应用启动等。
- 🔧 **配置方式**: 通过修改 `start.sh` 中的环境变量进行配置，包括设备 UDID（必需）、Appium 及服务器的主机、端口、路径和日志级别等。

### [ruler](https://github.com/intellectronica/ruler)

Ruler 是一个用于集中管理 AI 编码助手指令的工具，它通过一个统一的 `.ruler/` 目录来存储所有规则，并自动分发到不同 AI 代理的配置文件中，解决了多工具配置不一致和维护复杂的问题。

- 🎯 **核心功能**：集中管理规则、嵌套规则加载、自动分发配置、MCP 服务器传播和 `.gitignore` 自动化。
- 📁 **目录结构**：使用 `.ruler/` 目录存放规则文件（如 `AGENTS.md`）和配置文件（`ruler.toml`），支持嵌套结构以适应复杂项目。
- ⚙️ **配置管理**：通过 `ruler.toml` 配置默认代理、MCP 服务器和代理特定设置，支持全局和本地配置。
- 🔄 **命令使用**：`ruler init` 初始化项目，`ruler apply` 应用规则，`ruler revert` 撤销更改，支持多种选项和详细输出。
- 🌐 **支持的代理**：包括 GitHub Copilot、Claude、Cursor、Aider 等众多 AI 编码工具，每个代理有对应的配置文件和 MCP 设置。

### [claude-code-memory-bank](https://github.com/hudrazine/claude-code-memory-bank)

Claude Code Memory Bank 是一个专为 Claude Code 设计的结构化记忆管理系统，它通过持久化的项目上下文和自定义工作流命令，解决了多会话间上下文丢失的问题，从而提升 AI 辅助开发的效率和一致性。

- 🧠 **持久化上下文管理**：通过分层记忆文件（如 projectbrief.md、techContext.md 等）跨会话保存项目知识，避免每次重新开始。
- ⚙️ **自适应初始化**：使用 `/init-memory-bank` 命令自动检测项目状态，智能创建或补全记忆文件结构。
- 🔧 **自定义工作流命令**：提供 `/workflow:understand`、`/workflow:plan`、`/workflow:execute` 等命令，支持结构化任务执行与记忆更新。
- 📁 **项目无关与版本友好**：适用于任何技术栈，所有记忆文件均为 Markdown 格式，兼容版本控制系统（如 Git）。
- 🚀 **自动化文档生成**：在开发过程中自动创建和维护项目文档，形成有价值的副产品。
- 🌐 **开源与可扩展**：基于 Unlicense 许可开放使用，支持社区贡献和改进，可自定义命令与工作流。

## 其他
