---
title: 2025-第四十五周
date: '2025-10-29'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [Facebook.com 拥有 140 层上下文提供者：reactjs](https://old.reddit.com/r/reactjs/comments/1onblrs/facebookcom_has_140_layers_of_context_providers/)

一项对主流社交媒体网站 React Context 层数的调查显示，Facebook 以 140 层位居榜首，Bluesky 和 Pinterest 分别以 125 层和 116 层紧随其后。Facebook 工程师解释这是为优化性能而拆分的细粒度状态管理策略，通过减少重渲染提升体验。尽管存在开发体验问题，但目前未造成显著性能瓶颈。

- 🔍 Facebook 工程师证实拆分 Context 是为精准控制重渲染范围
- ⚡ 性能优化策略：将路由等复合上下文拆分为独立上下文避免连锁更新
- 🛠️ 当前依赖 React DevTools 分析重渲染原因，暂未采用 Context Selectors 方案
- 📊 前三名平台均超过 100 层 Context，Instagram(99) 和 Threads(87) 次之
- 🎯 细粒度 Context 通常仅包含布尔值等简单数据，最小化值变更影响范围
- 🔄 工程师通过 Chrome 性能面板→React DevTools 的流程定位渲染问题
- 💡 React 团队转向并发存储方案，Context Selectors 提案已被编译器优化替代

### [CSS 中“最招人烦”的功能：tan() 函数](https://css-tricks.com/the-most-hated-css-feature-tan/)

文章探讨了 CSS 中`tan()`函数的定义、数学原理及其在网页设计中的实际应用，特别是用于创建多边形布局和动态形状。

- 📐 `tan()`函数基于正切数学定义，即对边与邻边的比值，适用于处理三角形布局。
- 🔺 通过结合 CSS 变量和`tan()`，可以动态计算多边形切片的高度，实现自适应布局。
- 🎨 示例展示了如何用`tan()`构建分块列表、圆形菜单和图片画廊，增强视觉设计。
- 🧩 实际案例参考了社区创作，如对角线布局和拼图设计，体现了`tan()`的多样性。
- 📚 文章预告将深入介绍反三角函数（如`asin()`和`atan()`），完善 CSS 三角函数系列。

### [如何在 Chrome 开发者工具中限制特定请求速率 | DebugBear](https://www.debugbear.com/blog/chrome-devtools-throttle-individual-request)

Chrome DevTools 新增针对特定请求或域名进行网络限流的功能，目前需在 Chrome Canary 版本中启用。

- 🚀 启用方法：在 Chrome Canary 的 chrome://flags 页面开启"Enable individual request throttling in DevTools"选项
- 🖱️ 操作步骤：在开发者工具网络面板中右键目标请求，选择"Throttle requests"并指定 URL 模式
- 🌐 匹配模式：支持通配符配置（如`*://*/\*.woff` 匹配所有 Woff 字体文件）
- ⏱️ 延迟设置：可创建自定义限流配置文件，设置特定延迟时间（如 2000 毫秒）
- 📊 应用场景：测试特定资源加载延迟时的页面表现（如网页字体加载前的回退样式）
- 🔍 效果验证：可观察指定请求被限流而其他请求保持正常速度的运行状态

### [应用场景解析：Field Sizing](https://ishadeed.com/article/field-sizing/#conversional-ui)

概述了 CSS 的`field-sizing: content`属性，它能够根据输入框内容动态调整宽度，并介绍了其应用场景和注意事项。

- 🎯 该属性解决了输入框宽度自适应内容的问题，无需 JavaScript 即可实现。
- 🌍 目前仅 Chrome 浏览器支持此属性，但可渐进增强使用。
- 📏 使用时需设置`max-width`等限制，避免宽度过大或过小。
- 💬 适用于对话式 UI，使表单输入更自然，并尊重占位符文本宽度。
- 🧭 可用于表格内的选择菜单导航，提升用户体验。
- 🔗 特别适合 URL 输入框，如子域名或用户昵称字段。
- 🖼️ 在英雄区域等布局中，使选择菜单宽度更动态合理。
- ⚙️ 作为渐进增强功能，不支持时不影响基础表单功能。

### [精准指向的工具提示：基础篇 – Frontend Masters 博客](https://frontendmasters.com/blog/perfectly-pointed-tooltips-a-foundation/)

本文介绍了如何使用 CSS 的锚点定位 API 创建无需 JavaScript、能自动调整位置避免溢出的工具提示，包括基础配置、动态定位、添加尾部箭头等关键技术。

- 🎯 使用 CSS 锚点定位 API 替代 JavaScript 实现工具提示定位
- 📐 通过 position-area 属性控制工具提示相对于锚点的位置
- 🔄 利用 position-try-fallbacks 实现位置自适应，避免内容溢出
- 🎨 使用伪元素和 clip-path 创建工具提示的尾部箭头
- 📏 通过 anchor() 函数实现尾部箭头与锚点的动态对齐
- 🖱️ 支持上下两种初始位置配置，可根据需要灵活设置
- 🌐 目前仅 Chrome 和 Edge 浏览器完全支持相关功能

### [开发者 MCP 认证指南——WorkOS 篇](https://workos.com/blog/mcp-auth-developer-guide?utm_source=cpff&utm_medium=referral&utm_campaign=q42025)

本文全面介绍了 MCP 服务器的安全认证与授权机制，重点阐述如何通过 OAuth 2.1 和 PKCE 等技术构建安全可靠的 AI 代理系统。

- 🔐 MCP 采用 OAuth 2.1 作为核心认证协议，通过 PKCE 技术确保公开客户端的安全通信
- 🏗️ 系统架构包含三个核心组件：主机（AI 应用）、客户端（协议处理器）和服务端（业务逻辑执行器）
- 🔄 支持两种认证模式：API 密钥（适用于本地开发）和 OAuth（推荐生产环境使用）
- 🌐 通过 RFC 9728 保护资源元数据和 RFC 8414 授权服务器元数据实现自动发现机制
- 📝 采用 RFC 7591 动态客户端注册，实现无需人工干预的客户端自注册流程
- 🛡️ JWT 令牌验证包含签名验证、过期检查、发行者确认和受众验证等关键步骤
- 👥 基于角色的访问控制（RBAC）将 OAuth 范围映射到具体权限，实现最小权限原则
- 🔗 WorkOS 提供两种集成方案：自带用户的 OAuth 桥接和托管认证的 AuthKit 方案
- 📊 完整工作流涵盖发现、注册、授权、令牌使用和执行五个标准化阶段

## 工具

### [ycmjason/ts-migrating：此插件允许您在整个代码库中升级到所需的编译器选项（如严格模式、无未检查索引访问、仅可擦除语法），同时让有问题的代码行回退到旧的编译器选项。](https://github.com/ycmjason/ts-migrating)

该工具是一个渐进式 TypeScript 配置迁移插件，允许开发者在保持现有代码运行的同时，逐步升级到更严格的编译器选项。

- 🚀 支持渐进式升级 TypeScript 配置（如 strict 模式、noUncheckedIndexedAccess 等）
- 🛡️ 通过@ts-migrating 指令让问题代码行回退到原配置检查
- 🔧 包含 TypeScript 语言服务插件和独立 CLI 工具
- 📝 提供自动标注功能，可批量添加迁移指令
- ⚠️ 避免使用@ts-ignore 导致的错误掩盖问题
- 🔄 采用三阶段迁移流程：预防→修复→完成
- 💻 兼容主流 IDE 且不影响生产构建
- 📦 通过 npm 安装，在 tsconfig.json 中添加插件配置即可使用

### [yarlson/vite-plugin-use-golang](https://github.com/yarlson/vite-plugin-use-golang)

这是一个 Vite 插件，允许在 JavaScript 文件中编写 Go 代码并编译为 WebAssembly，使 Go 函数可在浏览器中作为 JavaScript 函数调用。

- 🚀 通过在 JS 文件顶部添加"use golang"指令，即可编写 Go 代码并自动编译为 WASM
- 🖼️ 主要用途：利用 Go 强大的标准库（如图像处理、加密等）在浏览器中执行复杂计算
- 🔧 需要安装 TinyGo 来保持 WASM 文件体积合理，标准 Go 编译的 WASM 文件过大
- 📦 安装简单：npm 安装插件后配置 Vite 配置文件即可使用
- 🔌 函数通过 js.Global().Set() 暴露给 JavaScript，在 window 对象上可用
- ⚡ 支持开发模式和生产构建，Go 代码变更时会自动重新编译
- 🎯 适用场景：图像视频处理、加密算法、数据解析等计算密集型任务
- 📝 提供完整配置选项，包括 TinyGo 路径、构建目录、优化级别等
- ⚠️ 注意事项：不支持热更新，需要特定函数签名，仅推荐在特定场景使用

### [nivandres/intl-t：一个完全类型化的基于对象的国际化翻译库](https://github.com/nivandres/intl-t)

这是一个名为 Intl-T 的完全类型化、基于对象的国际化翻译库，专为 TypeScript 设计，提供类型安全的翻译管理和灵活语法支持。

- 🎯 完全类型化，支持 TypeScript 自动补全和类型检查
- 🌲 基于节点的翻译结构，便于组织和管理多语言内容
- 🚚 支持 JSON 文件和动态远程导入
- 🧩 集成 ICU 消息格式，支持复杂复数形式和格式化
- ⚛️ 提供 React 组件注入和服务器端渲染支持
- 🔄 支持动态语言包导入，优化打包体积
- 📦 轻量级 4KB 包，无外部依赖且支持 Tree-Shaking
- ⭐ GitHub 上有 274 个星标和 6 个分支，采用 MIT 开源协议

### [lazarv/typescript-plugin-directives：TypeScript语言服务插件，为“use…”指令添加内联提示和悬停信息](https://github.com/lazarv/typescript-plugin-directives)

这是一个为 TypeScript 语言服务开发的插件，专门用于增强 IDE 对 "use …" 指令的支持和可视化展示。

- 🎯 **指令检测** - 自动识别模块作用域和导出函数中的各种指令
- 💡 **行内提示** - 在声明和导入旁边显示如 `<use server>` 的小型注释
- 📝 **悬停信息** - 为标记指令的导出提供详细的悬停提示
- ✅ **验证功能** - 检查无效指令并提供有用的错误信息
- 🔍 **导入追踪** - 识别导入函数是否源自指令标记的导出
- 🔌 **可扩展性** - 支持第三方包通过声明合并添加自定义指令
- 🎨 **框架无关** - 纯静态分析，无运行时依赖或指令语义
- 📦 **通用支持** - 兼容 `.js`、`.ts`、`.jsx` 和 `.tsx` 文件类型
- ⚙️ **安装配置** - 通过 npm/pnpm 安装，在 tsconfig.json 中添加插件配置
- 🔧 **开发贡献** - 提供完整的开发工作流，包括构建、测试和代码检查

### [npq](https://github.com/lirantal/npq)

npq 是一款在安装 npm 包之前对其进行安全审计的工具，通过多种检查机制来评估包的安全性，并最终交由包管理器完成安装。

- 🔍 检查包是否在 Snyk 漏洞数据库中存在已知安全漏洞
- 📅 验证包在 npm 上的存在时间（超过 22 天）
- 📊 检查包的月度下载量（超过 20 次）
- 📖 确认包包含 README 文件
- ⚖️ 验证包包含 LICENSE 文件
- ⚠️ 检测包是否包含可能恶意的预安装/后安装脚本
- 🌐 检查包是否包含有效仓库地址
- 📧 检测维护者邮箱是否使用过期域名
- 🔑 验证包的注册表签名
- 📦 检查包的来源证明元数据
- 🆕 检测版本发布是否超过 7 天
- 🖥️ 检查新版本是否引入新的命令行二进制文件
- 🔤 检测包名是否存在仿冒流行包的拼写错误风险
- 🚫 检查安装版本是否已被弃用
- 🛡️ 支持通过环境变量禁用特定检查项
- 💻 支持与 npm、yarn、pnpm 等包管理器集成使用
- 🎭 支持干运行模式仅进行检查而不实际安装
- 📝 支持纯文本输出模式

### [express-useragent](https://github.com/biggora/express-useragent)

`express-useragent` 是一个快速解析用户代理字符串的库，提供一流的 Express 中间件和 TypeScript 类型支持。它可在 Node.js 服务器端使用，也可通过轻量级 IIFE 包在浏览器中运行。

- 🚀 **快速用户代理解析器**：提供一流的 Express 中间件和完整的 TypeScript 类型支持。
- ⚙️ **环境兼容**：支持 Node.js 18 及以上版本，并可通过 IIFE 包在浏览器中运行。
- 📦 **安装简便**：通过 `npm install express-useragent` 即可安装。
- 🔧 **多种使用方式**：支持在原生 Node.js HTTP 服务器、Express 中间件及浏览器中直接解析。
- 🔄 **模块支持**：同时提供 ESM 和 CommonJS 模块导入方式，便于不同项目配置。
- 📋 **丰富的解析信息**：可解析出浏览器、操作系统、平台等详细信息，并提供如 `isMobile`、`isDesktop` 等便捷布尔属性。
- 🌐 **浏览器用法**：提供可直接引用的 IIFE 浏览器脚本，也支持通过打包器导入 ESM/CJS 模块。

### [MikroORM：基于数据映射器、工作单元和身份映射模式的 Node.js TypeScript ORM。 | MikroORM](https://mikro-orm.io/)

MikroORM 是一个功能丰富的 Node.js ORM 框架，支持自动事务管理、多种数据库类型、数据库同步工具、数据填充、查询优化和事件系统等特性。

- 🔄 自动事务处理：通过 `em.flush()` 自动将计算变更包装在数据库事务中
- 📝 简洁实体定义：利用源码分析技术，只需定义 TypeScript 类型即可完成实体配置
- 🗄️ 多数据库支持：兼容 MongoDB、MySQL、MariaDB、PostgreSQL、MS SQL Server、SQLite 等数据库
- 🔄 数据库同步工具：提供 SchemaGenerator 快速生成原型，Migrator 生成迁移差异，EntityGenerator 从数据库模式生成实体定义
- 🌱 数据填充功能：通过 Seeder 和种子工厂轻松生成任意规模和形状的假数据
- ⚡ 自动批处理：UnitOfWork 自动批量处理所有插入、更新、删除等查询操作
- 🔊 事件系统：强大的事件系统可挂钩实体生命周期，支持通过 onFlush 事件修改 UnitOfWork 行为
- 🔍 智能查询构建器：包含支持自动连接的元数据感知 QueryBuilder
- 🎯 全局过滤器：可定义和控制全局通用过滤器，支持多租户数据隔离和软删除实体自动隐藏

## 更新

### [在 Node 24 中使用 URLPattern 作为无框架路由器](https://jsdev.space/urlpattern-router-node24/)

JavaScript 现已在 Node.js 24 和浏览器中原生支持 URLPattern API，提供跨平台、无框架的路由解决方案，支持命名参数、正则验证和统一语义。

- 🌐 **原生跨平台支持**：URLPattern 在 Node.js 24 中全局可用，无需导入，同时兼容主流浏览器，实现客户端与服务端路由逻辑统一
- 🔧 **灵活路由匹配**：支持协议、主机名、路径等 URL 各部分匹配，提供命名捕获组、大小写控制和简洁模式语法
- ⚡ **轻量路由实现**：通过 PathRule 和 SmartRouter 类构建无依赖类型安全路由器，支持参数类型转换和复用模式实例
- 🛠️ **多环境适配**：同一套路由规则可同时用于 Service Worker 响应拦截和 Node.js HTTP 服务器处理
- 📊 **性能优化建议**：预编译 URLPattern 实例避免重复创建，限制用户输入的正则模式，在 Node 中始终使用绝对 URL
- ⚖️ **权衡考量**：虽不及专用路由库的极致性能，但为共享逻辑和统一验证提供了理想方案
- 🔍 **实用功能示例**：支持主机协议匹配、路径参数验证、查询参数处理，提供完整的请求上下文对象
- 🚀 **生产就绪**：具备足够的性能表现，适合轻量级 API 和服务 worker 场景，实现全栈路由定义一体化

### [Next.js 16 有哪些新特性](https://www.trevorlasn.com/blog/whats-new-in-nextjs-16)

Next.js 16 发布，这是一个稳定版本，将实验性功能转为稳定，移除已弃用的 API，并提升整体框架性能。

- 🚀 路由参数现在支持异步处理，包括页面、布局和路由处理程序，需使用 `await` 获取 `params` 和 `searchParams`，以优化流式渲染和并发性能。
- ⚡ Turbopack 成为默认打包工具，开发和生产构建速度显著提升，支持文件系统缓存和性能追踪。
- 🧠 集成 React 编译器，自动优化组件重渲染，减少手动使用 `useCallback` 和 `useMemo`。
- 💾 缓存 API 稳定化，引入 `cacheLife` 和 `cacheTag` 等控制缓存生命周期和标签失效功能。
- 🔄 中间件更名为代理，仅支持 Node.js 运行时，移除 Edge 运行时，专注于请求修改和重定向。
- 🗑️ 移除 AMP 支持，简化框架，推荐使用 Next.js 内置优化替代。
- 🖼️ 图像优化增强安全性和缓存，默认缓存 TTL 延长至 4 小时，支持远程模式和白名单配置。
- 🔧 环境变量替代运行时配置，移除 `serverRuntimeConfig` 和 `publicRuntimeConfig`，使用 `NEXT_PUBLIC_` 前缀区分客户端变量。
- 📝 集成 ESLint 替代 `next lint` 命令，迁移需使用代码修改工具更新配置。
- 🛠️ 升级策略包括运行自动化代码修改工具，手动修复复杂参数传递和类型更新，并全面测试路由、图像和中间件迁移。

## 设计

### [Figma 收购 Weavy AI](https://x.com/figma/status/1983889394944692359)

Figma 官方宣布收购 AI 设计工具 Weavy，将更名为 Figma Weave。此次收购将为 Figma 带来更多 AI 模型、更多工具和更多画布内创作方式，进一步增强 Figma 的 AI 能力，为设计师提供更强大的创作体验。

## AI

### [代理专用 Postgres](https://www.tigerdata.com/blog/postgres-for-agents)

Tiger Data 公司发布专为 AI 智能体设计的 Agentic Postgres 数据库，通过创新存储架构和工具集帮助开发者更高效地构建 AI 应用。

- 🚀 推出首个为 AI 智能体原生设计的数据库，具备 MCP 服务器、混合搜索和即时分叉功能
- 🤖 针对智能体行为特点优化：并行操作、即时检索、安全沙箱和专业知识调用
- 🔍 内置全文搜索 (pg_textsearch) 和语义搜索 (pgvectorscale) 扩展，支持混合检索
- ⚡ 基于 Fluid Storage 存储层实现零拷贝分叉，秒级创建数据副本且不增加成本
- 🛠️ 提供全新 CLI 工具和免费层级，支持快速部署和实验
- 📈 实测单存储卷吞吐量超 11 万 IOPS，保持弹性扩展和写时复制能力
- 🎯 目标让开发者专注于架构设计，将重复性工作交由智能体处理

### [基于模型上下文协议（MCP）的代码执行：打造高效能智能体体系](https://www.anthropic.com/engineering/code-execution-with-mcp)

### [MCP 遇上代码执行：构建更高效率的 AI 智能体](https://baoyu.io/blog/code-execution-with-mcp)

模型上下文协议（MCP）是一个连接 AI 智能体与外部系统的开放标准。本文探讨了在 MCP 使用规模扩大后，传统将所有工具定义预先加载到上下文窗口中的方法会导致高令牌消耗和延迟的问题，并提出了通过代码执行环境来更高效地与 MCP 服务器交互的解决方案，从而显著降低令牌使用量和成本。

- 🚀 **MCP 协议概述**：MCP 是一个开放标准，旨在解决 AI 智能体与外部工具及数据连接时的定制化集成难题，提供一个通用协议以实现规模化连接。

- 📈 **规模化挑战**：随着连接工具数量的增长，预先加载所有工具定义以及通过上下文窗口传递中间结果会拖慢智能体速度并增加成本。

- 🧩 **代码执行解决方案**：通过将 MCP 服务器呈现为代码 API 而非直接工具调用，智能体可以编写代码来交互，实现按需加载工具和在执行环境中预处理数据。

- 💰 **显著效率提升**：采用代码执行方法后，令牌使用量从 15 万降至 2 千，节省了 98.7% 的时间和成本。

- 🔍 **渐进式工具发现**：将工具作为文件系统中的代码文件呈现，允许模型按需读取工具定义，或通过搜索工具来动态加载所需工具，避免上下文膨胀。

- 📊 **高效数据处理**：智能体可以在代码执行环境中对大型数据集进行过滤、转换和聚合操作，仅将关键结果返回给模型，避免大量数据占用上下文窗口。

- 🔒 **隐私保护操作**：代码执行使得中间数据保留在执行环境中，模型仅接触显式记录或返回的数据。结合令牌化技术，可防止敏感信息进入模型上下文。

- 💾 **状态持久化与技能复用**：通过文件系统访问，智能体可以保存中间状态和将有效代码封装为可复用的技能函数，提升长期任务的效率和能力。

- ⚠️ **实施考量**：代码执行需要安全的沙箱环境、资源限制和监控，会引入额外的运营复杂性和安全考量，需权衡其收益与实施成本。

### [smart-excalidraw-next](https://github.com/liujuntao123/smart-excalidraw-next)

Smart-Excalidraw 是一个 AI 驱动的专业图表绘制工具，允许用户使用自然语言描述生成多种类型的图表，并支持在线编辑与本地部署。

- 🎯 **AI 驱动制图**：通过大语言模型理解需求，自动生成结构清晰、布局合理的专业图表。
- 🔗 **智能连接算法**：采用独创箭头优化算法，自动计算最佳连接点，避免线条混乱。
- 📊 **丰富图表支持**：支持 20 多种类型，包括流程图、架构图、时序图、ER 图、思维导图等。
- 🎨 **无缝集成编辑**：基于 Excalidraw 格式，生成后可自由调整样式、添加细节，结合 AI 生成与手动精修。
- ⚡ **简易配置使用**：只需配置 AI API 密钥即可开始，所有设置保存在本地浏览器，保障隐私安全。
- 🌐 **在线与本地部署**：提供在线网站直接使用，也支持本地克隆项目并启动开发服务器进行部署。
- ❓ **常见问题解答**：推荐使用 Claude-Sonnet-4.5 模型，强调数据本地保存的安全性和生成的图表可自由编辑。
- 🛠️ **技术栈**：基于 Next.js 16、React 19、Excalidraw、Tailwind CSS 4 和 Monaco Editor 开发。

### [Hephaestus](https://github.com/Ido-Levi/Hephaestus)

Hephaestus 是一个半结构化智能体框架，它允许 AI 工作流根据智能体的实时发现动态构建任务，而非依赖预先定义的指令。该框架通过定义工作阶段类型（如分析、实施、验证），使智能体能够在任何阶段基于发现创建新任务，从而实现工作流的自适应扩展和协调。

- 🔥 框架核心：半结构化设计，结合阶段定义的结构性和智能体动态创建任务的灵活性
- 🌳 自适应工作流：智能体在测试或实施过程中发现优化或问题时可自主创建新任务，形成分支工作流
- 📋 阶段协调：定义分析、实施、验证等阶段类型，智能体跨阶段协作并通过看板管理依赖关系
- 🛡️ 监控保障：守护者系统监控智能体行为，确保其与阶段目标保持一致
- 🚀 快速启动：提供验证脚本和详细指南，支持在 10 分钟内开始使用
- 📚 丰富资源：包含完整文档、示例工作流和社区支持，便于学习和应用
- 🔧 技术栈：基于 Python 构建，集成 Docker、Qdrant 向量数据库和 Claude Code 等工具

### [OpenSpec 使用心得](https://4ark.me/posts/2025-11-04-openspec/#3-%E5%88%9B%E5%BB%BA%E6%8F%90%E6%A1%88)

在 2025 年，借助 AI 工作已成为开发者必备技能。本文介绍了 AI 工具从基础补全到自主驱动的演进过程，并提出了使用 OpenSpec 规范驱动开发解决团队协作痛点的方法，通过案例演示了从提案到实施的完整流程，最终实现从微观操作到宏观管理的角色转变。

- 🚀 **AI 工具演进**：从简单的代码补全发展到能自主理解任务、调用工具的智能 Agent
- 🤝 **解决协作痛点**：OpenSpec 通过结构化提案和持久化规范，解决上下文干扰、信息丢失和难以复用问题
- 📝 **规范驱动开发**：每次改动前先形成 proposal.md 明确原因、内容和影响，Review 通过后再执行
- 👨‍💼 **角色转变**：开发者从微观指挥转变为宏观把关，AI Agent 负责具体执行
- 🛠️ **实践案例**：以撰写文章为例展示 OpenSpec 完整流程，包括初始化、创建提案、反复打磨到实施归档
- 💡 **核心价值**：项目规范文件成为团队核心资产，确保新成员和工具能快速理解项目约定

### [code-graph-rag-mcp](https://github.com/er77/code-graph-rag-mcp)

这是一个用于代码分析的 Model Context Protocol 服务器项目，能够创建智能的代码图表示并进行语义分析。

🌟 项目概述

- 🚀 支持 10 种编程语言的代码分析，性能提升 5.5 倍
- 🔍 提供语义搜索、代码相似性检测等 24 种 MCP 方法
- 📊 支持 Python、TypeScript/JavaScript、C/C++、C#、Rust、Go、Java、VBA 等多语言
- ⚡ 采用高性能架构，解析速度达 100+ 文件/秒，查询响应 < 100ms

🛠️ 核心功能

- 🔬 语义搜索：支持自然语言代码搜索
- 📋 代码相似性检测：识别重复代码和重构机会
- 📈 影响分析：预测代码变更的影响风险
- 🤖 AI 重构：提供智能代码改进建议
- 🌐 跨语言分析：支持多语言代码库关系分析

🚀 快速开始

- 📦 安装：`npm install -g @er77/code-graph-rag-mcp`
- 🔧 支持 Claude Desktop、Gemini CLI、Codex CLI 等多种客户端集成
- ⚙️ 支持多代码库同时分析

📊 性能表现

- ⚡ 执行时间：从 55.84 秒优化到 < 10 秒
- 💾 内存使用：优化至 65MB
- 🎯 准确性：基于语义分析，优于基于模式的方法

🔄 最新版本

- 🚀 v2.7.4：新增克隆报告和 CLI 增强功能
- 🔄 改进了代码克隆检测，合并了去重后的语义组与 JSCPD 摘要
- 📊 JSCPD 检测现在包含重复行数/令牌计数和百分比统计

## 其他

### [AI 智能体（Agentic AI）现状：创始人篇](https://baoyu.io/translations/state-of-agentic-ai-founders-edition)

本文探讨了 AI 智能体在企业中的部署现状、挑战及成功策略，基于对欧洲 30 多家 AI 智能体初创公司创始人和 40 多位从业者的调查与访谈。研究发现，部署的主要挑战并非技术问题，而是工作流集成、员工抵触及数据安全等非技术因素。成功的部署策略强调从小型、低风险任务入手，快速展示投资回报率，并定位为增强人类能力的“副驾驶”。此外，定价策略多样，但混合模式和按任务收费最为常见。尽管生态系统尚不成熟，多数初创公司仍选择内部构建基础设施，并报告了较高的准确率水平。

- 🎯 **关键挑战**：AI 智能体部署的最大难题是工作流集成和人机界面（60%）、员工抵触等非技术因素（50%）以及数据隐私和安全（50%）。
- 🚀 **部署策略**：采用“从小处着想”方法，从低风险、中等影响的任务开始，快速证明 ROI，并优先自动化人类厌恶的流程。
- 💰 **预算动向**：62% 的初创公司已动用业务线或核心预算，表明 AI 智能体正超越实验阶段，进入主流业务应用。
- 📊 **定价模式**：混合型（23%）和按任务收费（23%）最常用，而按结果付费（3%）因归因和监控困难仍较少见。
- 🛠️ **基础设施**：52% 的初创公司主要或完全在内部构建智能体基础设施，反映生态系统的早期阶段。
- ✅ **准确性与自主性**：90% 以上初创公司报告准确率超 70%，但仅 66% 在自主性水平超 70% 下运行；可接受准确率因行业和用例而异。
- 🤝 **员工接受度**：高自主性解决方案更易引发员工抵触，凸显信任问题；成功部署需注重教育、娱乐和预期管理（3E 框架）。
- 📈 **采用水平**：企业部署多集中于客户支持、销售和网络安全等成熟领域，但日常员工使用率仍较低，常引发“影子 AI”问题。
- 🔄 **未来展望**：AI 智能体需从被动响应向环境智能体和主动智能体演进，以处理更复杂任务并适应开放环境。

### [AI 到底在抢谁的饭碗？我分析了 1.8 亿份招聘数据后，有了一些发现。](https://baoyu.io/translations/i-analyzed-180m-jobs-to-see-what-jobs-ai-is-actually-replacing-today)

本文基于对 2023 年 1 月至 2025 年 10 月期间全球近 1.8 亿份招聘帖文的分析，揭示了 AI 对就业市场的具体影响。研究发现，AI 的影响具有选择性，并未导致大规模失业，但显著改变了某些职位的需求格局。

- 📉 2025 年全球招聘帖文总量同比下降 8%，为分析基准线。
- 🎨 执行类创意岗位大幅减少：电脑图形美术师 (-33%)、摄影师 (-28%) 和文字工作者 (-28%) 连续两年下降。
- 🌿 合规与可持续发展职位急剧萎缩：企业合规专员 (-29%)、可持续发展专员 (-28%) 因政策变化大幅减少。
- 🏥 医疗记录员岗位下降 20%，可能受 AI 文档工具影响，但需更多数据确认趋势。
- 🚀 AI 基础设施职位快速增长：机器学习工程师激增 40%，机器人工程师 (+11%) 等同步增长。
- 👔 高级领导层最稳定 (-1.7%)，明显优于中层管理者 (-5.7%) 和基层员工 (-9%)。
- 📱 网红营销专员逆势增长 18.3%，成为数字营销中少数亮点。
- 💻 软件工程师岗位保持稳定，AI 工具提升效率而非取代岗位。
- 🎯 客服代表仅下降 4%，表现优于市场基准，显示 AI 替代有限。
- 📈 销售岗位整体稳定，营收总监增长 10.2%，体现公司对增长思维的转变。

研究显示就业市场呈现“分化”趋势：策略性岗位优于执行岗，领导层优于基层，网红营销优于传统营销。软件工程、客户服务等需要复杂问题解决能力和同理心的岗位依然坚挺。
