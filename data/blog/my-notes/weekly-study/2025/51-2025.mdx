---
title: 2025-第五十一周
date: '2025-12-04'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [TypeScript 类型作为一种编程语言](https://marmelab.com/blog/2025/12/04/typescript-type-as-a-programming-language.html)

本文探讨了将 TypeScript 类型系统视为一门编程语言，通过类比编程概念（如函数、条件、变量和循环）来构建高级泛型类型，以提升代码的通用性和类型安全性。

- 🧩 **泛型类型如同函数**：可定义依赖其他类型的类型，通过输入类型产生输出类型，支持类型约束和默认值。
- 🔗 **条件类型实现分支逻辑**：使用 `extends` 关键字和三元语法进行类型条件判断，例如从事件类型中提取特定字段。
- 🔍 **infer 关键字用于类型提取**：允许在类型定义中创建变量，支持解构，简化复杂类型的推导过程。
- 🔄 **递归类型处理循环结构**：类型可调用自身，适用于树形数据或数组遍历，如实现查找特定类型的 `Find` 工具。
- 📝 **模板字面量类型操作字符串**：支持字符串拼接和复杂操作（如移除空格），可用于生成方法名等场景。
- 🗺️ **映射类型迭代对象属性**：结合 `keyof` 和 `in` 关键字，可转换对象属性，例如将方法返回类型包装为 Promise。
- 🛠️ **实用工具类型增强灵活性**：如 `ReturnType` 和 `Parameters`，可提取函数返回类型和参数类型，支持更动态的类型定义。
- 🎯 **实际应用提升代码质量**：通过 CRUD 生成器、中间件结果类型推断等示例，展示如何减少重复代码并增强编译时错误检测。

### [React 中 useEffectEvent 的注意事项](https://slicker.me/react/useEffectEvent.html)

useEffectEvent 是一个实验性的 React Hook，用于从 Effect 中提取非响应式逻辑，允许在 Effect 内读取最新的 props 或 state 值，而不会因这些值的变化导致 Effect 重新执行。

- 🧩 **解决核心问题**：在 Effect 中读取最新值但避免不必要的重新运行，例如聊天室应用中记录房间切换时包含当前主题，而主题变化时不触发 Effect 重新执行。
- ✅ **正确用法**：在 Effect 内直接调用、用于读取最新 props/state 而不添加依赖、分离响应式与非响应式逻辑、同步调用。
- ❌ **错误用法**：在常规事件处理器或渲染中调用、作为 prop 传递、异步调用、替代正确的记忆化。
- 📊 **常见用例**：日志记录与数据分析、使用最新状态的回调、基于最新值的防抖处理。
- ⚠️ **注意事项**：仅用于真实需求，保持函数目的单一，等待稳定版再用于生产，优先考虑逻辑重构。

### [使用 Prisma 管理 Next.js Monorepo | AppSignal 博客](https://blog.appsignal.com/2025/11/26/manage-a-nextjs-monorepo-with-prisma.html)

本文介绍了如何在 Next.js 单仓库（monorepo）中集成 Prisma 来构建一个披萨订购应用，涵盖项目初始化、Prisma 配置、数据库查询和订单管理的完整流程。

- 🚀 使用 Next.js 和 Prisma 在单仓库中构建全栈应用，实现前后端类型与逻辑共享
- 🛠️ 通过 Prisma 初始化数据库模型（用户、订单、订单项、披萨）并运行迁移
- 🌱 配置种子脚本预填充数据库数据，利用唯一约束避免重复条目
- 🔌 创建全局 Prisma 客户端实例，通过扩展优化性能并避免开发环境重复实例化
- 📊 在 Next.js 组件中直接查询数据库，展示用户和披萨列表，实现类型安全操作
- 📝 构建订单管理界面，支持查看订单详情、取消订单及创建新订单功能
- ⚡ 利用 Next.js 服务端操作处理表单提交，实现数据更新与页面重定向
- 🎯 单仓库架构减少后端分层，使用统一 TypeScript 栈提升开发效率与一致性

### [我未能用 Claude 重现 1996 年《空中大灌篮》网站 | j0nah.com](https://j0nah.com/i-failed-to-recreate-the-1996-space-jam-website-with-claude/)

作者尝试使用 Claude AI 仅凭截图和素材文件复刻 1996 年《太空大灌篮》官网，但最终失败。整个过程揭示了 Claude 在视觉空间精确测量和自省修正方面的核心局限。

- 🎯 **任务设定**：提供官网截图和素材，要求 Claude 精确复刻采用绝对定位的静态页面
- 🤖 **盲目自信**：Claude 初期声称完美复刻，实际布局存在明显偏差，且自我评估与输出结果脱节
- 📏 **测量缺陷**：Claude 承认无法获取精确像素坐标，仅能进行视觉估算，导致定位误差
- 🛠️ **工具失效**：作者添加网格覆盖、坐标参考、分屏对比等辅助工具后，Claude 仍陷入自我验证循环
- 🔍 **视觉局限**：推测 Claude 的视觉编码器将图像分块处理，丢失细节精度，导致语义理解与几何执行不匹配
- 📈 **错误固化**：每次迭代调整仅微调错误布局，未能突破初始错误的空间认知框架
- 🧩 **分区尝试**：将截图分割为六个区域分别分析，仍无法改善定位精度
- 🔬 **放大实验**：提供 200% 放大截图试图增强细节识别，但 Claude 未能正确处理比例换算
- 🧠 **认知矛盾**：能够准确描述布局概念（如“行星环绕排列”），却无法转化为精确的 CSS 坐标
- 🏁 **未解难题**：最终承认失败，认为这个 28 年前的网页设计意外成为 AI 空间推理能力的基准测试

## 工具

### [Vercel 发布新 npm 包：自动修复流式 Markdown 中断问题](https://vercel.com/changelog/new-npm-package-for-automatic-recovery-of-broken-streaming-markdown)

Remend 是一个独立的 JavaScript 包，专门用于智能处理 AI 流式输出中常见的未完成 Markdown 语法，确保其在任何应用程序中都能被正确渲染。

- 📦 **独立发布**：Remend 原本是 Streamdown 的一部分，现已作为独立库（`npm i remend`）发布，可集成到任何应用中。
- 🤖 **解决核心问题**：AI 模型逐令牌流式输出 Markdown 时，常产生未闭合的代码块、粗体标记、链接或列表，导致渲染失败或布局混乱。
- 🛠️ **自动补全**：它能自动检测并补全未终止的 Markdown 块，在流式传输中提供稳定、干净的输出。
- 🔌 **即插即用**：可作为任何 Markdown 渲染器的预处理步骤，与 unified 等工具链无缝配合。
- 🧪 **经过实战检验**：已在 Streamdown 及生产级 AI 应用中经过测试，能智能处理数学表达式、产品代码、嵌套链接等复杂边缘情况。
- 🚀 **快速上手**：可通过 Streamdown 使用，或直接通过 `npm i remend` 安装独立库。

### [GitHub - filipsobol/sonda：适用于JavaScript和CSS的通用可视化工具与分析器。兼容多数打包工具和框架。](https://github.com/filipsobol/sonda)

Sonda 是一款通用的 JavaScript 和 CSS 可视化分析工具，兼容主流打包工具和框架，通过分析源码映射提供精确的打包报告。

- 🛠️ **通用分析工具** – 支持 Vite、Rollup、webpack 等多种打包工具，以及 Next.js、Nuxt、Astro 等框架
- 📊 **精准可视化报告** – 基于源码映射分析，展示 Tree Shaking 和压缩后的模块体积，生成交互式 HTML 报告
- 🌐 **在线体验** – 提供官方文档和在线演示，便于快速了解和使用
- 📦 **开源项目** – 采用 MIT 许可证，拥有活跃的社区维护和版本发布
- ⭐ **受欢迎程度** – 在 GitHub 上获得大量关注，被众多项目所使用

### [GitHub - platformatic/kafka](https://github.com/platformatic/kafka)

这是一个用于 Apache Kafka 的现代、高性能、纯 TypeScript/JavaScript 类型安全客户端库。

- 🚀 **高性能**：针对速度进行了优化。
- 🧩 **纯现代 JavaScript**：使用最新的 ECMAScript 功能构建，无需原生插件。
- 🔒 **类型安全**：提供完整的 TypeScript 支持和强类型。
- 🔄 **灵活的 API**：所有 API 都支持 Promise 或回调函数。
- 🌊 **流式或事件驱动消费者**：借助 Node.js 流，可以选择首选的消费方式。
- 🛠️ **灵活的序列化**：支持可插拔的序列化和反序列化器。
- 🔗 **连接管理**：自动连接池和恢复机制。
- 📦 **低依赖**：外部依赖极少。
- 📚 **全面功能**：提供生产者、消费者和管理员客户端 API。
- 🛡️ **错误处理**：定义了清晰的错误层次结构，便于调试。
- 📈 **性能调优**：内部优化以减少事件循环开销，支持高水位线配置。
- 📄 **丰富文档**：包含详细的 API 参考和示例代码。

## 更新

### [发布 6.1.0 版本 · ant-design/ant-design · GitHub](https://github.com/ant-design/ant-design/releases/tag/6.1.0)

Ant Design 发布了 6.1.0 版本，包含多项新功能、问题修复和优化，涉及 ConfigProvider、Alert、Drawer、Select、Table、Button、Menu 等组件，并进行了依赖库迁移和 TypeScript 类型更新。

- 🆕 ConfigProvider 新增支持配置 Tooltip、Popover 和 Popconfirm 的 trigger 属性。
- 🆕 Alert 和 Drawer 新增语义化关闭按钮元素，Drawer 还支持 resizable 的布尔类型设置。
- 🆕 Select 新增 optionFilterProp 多字段搜索功能。
- 🐞 修复了 Select 在非搜索状态下显示输入光标、选项未打开等问题。
- 🐞 修复了 Table 的 cellFontSizeSM 和 cellFontSizeLG token 不生效的问题。
- 🐞 修复了 Button 部分 Token 在特定变体下不生效的问题。
- 💄 修复了 Menu 组件 item 中定义的 style 不生效的错误。
- 🛠 更新了 @ant-design/react-slick 版本以删除 classnames，并迁移了 rc-overflow 和 rc-virtual-list 以删除 rc-util。
- 🤖 TypeScript 方面，Alert 新增导出 ErrorBoundaryProps 类型，ConfigProvider 支持 Table rowKey 传入函数，Notification 的 title 属性改为可选。

### [TypeScript 7 进展 - 2025 年 12 月 - TypeScript](https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/)

TypeScript 7.0（代号“Corsa”）的开发进展顺利，其原生编译器与语言服务已进入预览阶段，性能显著提升，并计划作为 TypeScript 6.0 之后的下一个主要版本发布。

- 🚀 **性能大幅提升**：原生编译器（tsgo）在完整构建中相比 TypeScript 6.0 有近 10 倍速度提升，并支持多线程并行构建。
- 🔧 **编辑器支持完善**：VS Code 扩展预览版已提供代码补全（含自动导入）、跳转定义、重命名等核心语言服务功能，日常使用稳定。
- ✅ **类型检查高度兼容**：TypeScript 7.0 的类型检查已接近完成，在数千个测试用例中与 6.0 的错误检测结果基本一致。
- 📦 **编译器功能就绪**：支持增量编译（--incremental）、项目引用和构建模式（--build），大多数项目可无缝尝试。
- ⚠️ **注意变更与限制**：将移除部分已弃用功能（如--target es5），JavaScript/JSDoc 类型检查更严格，且暂不完全支持旧版 API 与低版本 ES 目标编译。
- 🛑 **版本过渡明确**：TypeScript 6.0 将是最后一个基于 JavaScript 代码库的版本，后续主要开发将集中在 7.0 上，以加速原生生态成熟。
- 📢 **鼓励开发者试用**：团队邀请用户通过 VS Code 扩展和 npm 包（@typescript/native-preview）体验预览版，并反馈问题以帮助完善。

## 设计

### [2026 年构建设计系统](https://engineering.udacity.com/building-a-design-system-in-2026-5cfd8d85043c)

本文概述了构建现代设计系统（特别是针对 2026 年）的核心原则与实用建议，强调避免过度工程化，追求低维护成本和高效率。作者基于多年经验，指出常见陷阱并推荐以成熟的开源组件库为基础的最小可行产品方案。

- 🎯 **设计系统的本质**：设计系统是确保产品设计开发一致性、提升效率的集中化指南、可复用组件和标准的集合，包含色彩、字体、UI 组件等，为团队提供统一依据。
- ⚠️ **常见陷阱与核心原则**：避免追求“完美”系统而导致过度维护；最大的误区是自行构建组件库，这会带来版本管理、开发速度、长期维护等沉重负担。核心目标是**低维护、低摩擦**。
- 🚀 **推荐 MVP 构成**：1. 设计语言（色彩、字体等视觉基础）；2. Figma 库（发布设计变量与组件）；3. **选择强大的开源组件库**作为基石；4. 代码基础设施（推荐使用 Turborepo/NX monorepo，配套 Storybook 等工具）；5. 为所选组件库构建并发布主题包。
- 📦 **选择组件库的关键标准**：开源且流行（如 GitHub stars > 20k）、**强大的主题定制功能**、丰富的组件目录、详细文档、开箱即用的无障碍与国际支持、优异的性能与包体积，以及可选的 AI 助手 MCP 服务器支持。
- ⚛️ **React 库推荐**：在 Mantine、Chakra 和 MUI 中，**Mantine 是首选**，因其组件更丰富、主题模型更灵活、采用零运行时样式性能更优，且提供大量实用工具。
- 🔧 **关于 Shadcn 的说明**：虽适用于个人项目，但不适合企业级设计系统，因为它本质上仍需自行构建和维护组件库，违背了“避免维护自有组件库”的首要原则。
- ✨ **总结与展望**：2026 年的设计系统应立足**务实**，专注于减少摩擦、提升团队效率。通过夯实设计语言、借助开源生态、选择合适组件库，才能构建出持久、灵活且易于维护的系统，使团队更快、更一致地构建优秀产品。

## AI

## 其他

### [前端十大戒律 | Felipe Gustavo 的博客](https://www.felgus.dev/blog/ten-frontend-commandments)

本文总结了前端开发的十条实用准则，旨在帮助开发者高效管理项目、协调团队并确保交付质量。

- 🛑 若当前版本已获认可，无需额外改动
- 🤝 面对复杂设计需求，拉上业务方共同决策
- 👥 促进设计师与业务方直接沟通以简化方案或调整排期
- ⏳ 提前与后端协调需求并明确责任
- 🌙 选择低峰时段部署以减少用户对问题的感知
- 📝 在工单中详细记录修改内容和决策依据
- 📱 全面测试不同分辨率及弱网/低性能设备表现
- ⏰ 工期紧张时优先保障核心功能与用户流程
- 🔍 紧密配合测试团队，快速修复问题
- ⚖️ 合理评估工期，避免过度承诺
