---
title: 2025-第四十周
date: '2025-09-28'
tags: ['WEEKLY-2025']
draft: false
summary: ''
---

`该周报主要为各个地方内容的汇总整理`

<TOCInlineWithSticky toc={props.toc} />

## 技术

### [React 渲染行为与子组件相关的微妙之处](https://blacksheepcode.com/posts/nuance_of_react_rendering_behaviour)

本文通过对比两种 React 组件渲染模式，分析了 props.children 与直接渲染子组件在渲染行为上的差异，并探讨了 React 19 编译器如何优化这一行为。

- 🔍 直接渲染的子组件会在父组件状态更新时重新渲染，而通过 props.children 传递的子组件则不会
- 🌳 React 官方文档未区分两种子组件渲染方式，但实际渲染行为存在差异
- ⚙️ JSX 编译后，直接渲染的组件会生成新的 React 元素对象，而 props.children 保持引用不变
- 🔄 渲染差异源于 React 对前后渲染元素的浅比较（===），引用相同则跳过重新渲染
- 🚀 React 19 编译器通过"use memo"注解可自动优化组件，消除两种模式的渲染差异
- 💡 开发者可通过 Babel 插件渐进式启用编译器优化功能

### [为何 Next.js 在软件工程方面存在不足](https://blog.webf.zone/why-next-js-falls-short-on-software-engineering-d3575614bd08)

本文是一位资深软件架构师对 Next.js 框架的深度批判。作者认为 Next.js 作为一个全栈框架，在软件抽象、架构分层、可组合性以及企业级应用所需的关键特性上存在严重缺陷。其核心论点是 Next.js 提供的抽象是泄露且过度复杂的，它模糊了代码执行环境的界限，导致了紧耦合的架构，这违背了良好的软件工程原则，如松散耦合、清晰的生命周期和模块化设计，因此不适合作为大型、可持续系统的基础。

- 🚨 **抽象法则的违背** - 作者提出，只有当抽象能隐藏复杂性或增加新能力时才有效，而 Next.js 的抽象常常是过度且泄露的，未能满足这两个核心要求。
- 🧱 **架构分层缺失** - Next.js 将其 CLI、打包器、路由器和运行时紧密耦合，使得替换或扩展其中任何一层都异常困难，破坏了松散耦合的软件工程基本原则。
- 🤹 **心智模型复杂** - 框架将 CSR、SSR、SSG、ISR 等多种渲染模式塞进一个系统，迫使开发者同时关注构建时、服务器运行时和客户端运行时等多个维度，增加了认知负担。
- 🔌 **可插拔性不足** - 与 Astro 等框架相比，Next.js 缺乏清晰的插件接口，集成第三方工具（如 CMS）时常需要将细节泄露到应用代码中。
- 🌍 **环境变量混淆** - Next.js 模糊了构建时和运行时环境变量的界限，这使得遵循 12-Factor 应用原则（尤其是构建一次，多处部署）变得困难甚至不可能。
- ⚙️ **生命周期管理缺失** - 缺乏官方的、可靠的一次性初始化或应用启动生命周期钩子，开发者需要依赖非官方技巧来实现。
- 🖥️ **自定义服务器与中间件支持不佳** - 使用自定义服务器（如 Koa, Fastify）体验很差，功能受限；中间件对 Node.js 运行时的支持也姗姗来迟且行为怪异。
- 📦 **应用打包与组合困难** - 缺乏有效的应用级组合抽象，难以构建可复用的、模块化的大型系统，例如作为 NPM 包发布的基础应用。
- 🏢 **企业级场景受限** - 在需要动态主题、多团队模块化平台、严格的企业发布流水线（金融行业）或双许可证产品等复杂场景下，Next.js 的约束使其无法胜任。
- 🎯 **定位偏差的结论** - 作者认为 Next.js 本质上是一个渲染工具，却以全栈框架自居。它未能提供真正的框架应有的清晰生命周期、架构约束和组合能力，因此不建议作为大型、架构良好的应用程序的基石。

### [掌握 NPX：npm 与 Node.js 高手的速查手册](https://www.nodejs-security.com/blog/mastering-npx-cheatsheet-npm-nodejs-power-users)

NPX 是 Node.js 生态中强大的命令行工具，主要用于直接执行 npm 包而无需全局安装，同时支持指定 Node 版本、运行 GitHub 脚本及环境变量配置等进阶功能。

- 🚀 直接执行 npm 包（如 npx create-react-app），自动下载并清理缓存
- 🗺️ 使用-p 参数定位可执行文件路径（如 npx -p shellcheck which shellcheck）
- 🔧 通过-p 指定 Node.js 版本运行命令（如 npx -p node@14 `<command>`）
- 📜 直接执行 GitHub Gist 脚本（npx gist `<gist-id>`）
- 🌡️ 支持传递环境变量（如 MY_VAR=value npx `<package>`）
- ⚠️ 需注意执行未经验证代码的安全风险，建议使用 npq 等工具审计

### [你对媒体查询真正了解多少？——前端大师博客](https://frontendmasters.com/blog/learn-media-queries/)

本文深入探讨了 CSS 媒体查询的多样性和应用，指出除了常见的响应式设计查询外，还有许多被忽视但功能强大的媒体查询描述符，可用于适配不同设备能力、用户偏好及特殊显示模式，并介绍了新的语法和嵌套写法。

- 🖱️ 通过 `hover`、`pointer` 等查询输入设备能力，可针对触摸屏、鼠标、游戏手柄等优化交互样式
- 🎨 使用 `forced-colors` 适配系统强制色彩模式，并通过 `forced-color-adjust` 保护特定颜色
- 📏 `width`/`height` 支持新的比较运算符语法（如 `width > 900px`），提供更精确的视口范围控制
- 🔄 `inverted-colors` 检测颜色反转模式，可通过调整色相值修复阴影和媒体显示效果
- 📱 `orientation` 结合触摸设备描述符，可针对横竖屏握持方式优化布局
- 📜 `overflow-inline`/`overflow-block` 检测滚动支持，适用于分页媒体或无滚动环境
- 🌙 `prefers-color-scheme` 配合 `light-dark()` 函数，可轻松实现明暗主题切换
- ◐ `prefers-contrast` 适配对比度偏好，需特别注意低对比度用户的可访问性
- 📉 `prefers-reduced-data` 为蜂窝网络用户减少数据消耗，可条件加载图片字体
- ⏸️ `prefers-reduced-motion` 为前庭障碍用户减少动画效果，提升舒适度
- ✨ `prefers-reduced-transparency` 允许用户降低透明效果，改善可读性
- 🖼️ `resolution` 结合范围语法，可为高分辨率设备提供高清图片资源
- 🪆 CSS 嵌套现已原生支持媒体查询，允许更上下文化的代码组织

### [如何利用 React Router 内置数据去重功能 by sergiodxa](https://sergiodxa.com/tutorials/leverage-react-router-s-built-in-data-deduplication)

React Router 7.0.0 内置了智能数据去重机制，当使用 Promise.all 等组合多个数据请求时，框架会自动检测共享数据并通过引用传输而非重复传输值，从而优化网络性能。

- 🚀 自动去重：React Router 在组合 Promise 时自动识别重复数据，使用引用代替实际值传输
- 🔗 引用机制：通过指针标识数据关系，如 P6/P8 指向独立数据，P10 通过 [[14,13]] 引用已传输数据
- ⚡ 流式传输：数据分块发送，每个 Promise 解析后立即传输对应数据片段
- 🎯 智能关联：框架理解数据依赖关系，组合 Promise 仅传输引用而非重复数据
- 📦 复杂结构优化：对包含多个属性的对象同样有效，显著减少带宽占用
- 💡 无感优化：开发者使用标准 Promise 语法即可自动获得去重收益
- 🛒 实际价值：在电商等复杂场景中避免用户信息、商品数据等重复传输
- 🎪 渐进加载：配合 Suspense 和 Await 实现细粒度加载状态管理

### [2025 年 React 状态管理：你真正需要掌握的核心要点](https://www.developerway.com/posts/react-state-management-2025)

本文探讨了 2025 年 React 状态管理的实际需求，指出大多数情况下并不需要专门的状态管理库，并针对不同状态类型推荐了相应的解决方案。

- 🎯 状态管理决策应基于具体需求，没有"最佳"通用方案
- 🌐 远程状态推荐使用 TanStack Query 或 SWR 库处理数据获取和缓存
- 🔗 URL 状态可通过 nuqs 库实现与本地状态的高效同步
- 🏠 本地状态直接使用 React 内置的 useState 或 useReducer 即可
- 🔄 共享状态可先用 Context 解决，复杂场景再考虑状态管理库
- ⚡ Zustand 因简单易用且符合 React 理念成为作者首选共享状态方案
- 📊 通过分类处理不同状态类型，可消除约 90% 的状态管理问题

## 工具

### [NickvanDyke/eslint-plugin-react-you-might-not-need-an-effect：捕获不必要的React useEffect 钩子，使代码更简洁、快速和安全。](https://github.com/NickvanDyke/eslint-plugin-react-you-might-not-need-an-effect)

这是一个用于检测 React 中不必要 useEffect 钩子的 ESLint 插件，旨在帮助开发者编写更简洁、高效和可靠的代码。

- 🎯 核心功能是捕获不必要的 useEffect 使用，使代码更易维护且减少错误
- 📦 支持通过 npm 或 yarn 安装，提供推荐配置和自定义配置选项
- ⚡ 包含 11 条具体规则，涵盖派生状态、状态更新链、事件处理等常见误用场景
- 🛠️ 提供详细的规则文档和测试用例，帮助开发者理解各种使用场景
- 📚 基于 React 官方最佳实践，特别推荐给 React 新手学习正确的思维模式
- 🔧 可与 react-hooks/exhaustive-deps 规则配合使用以获得更准确的分析

### [shuding/legid：用于生成安全、合法且随机的URL兼容ID的库。](https://github.com/shuding/legid)

一个用于生成安全、合法且随机的 URL 兼容 ID 的库，解决客户端 ID 生成可能被篡改的问题。

- 🔒 防止客户端 ID 被恶意篡改，避免如生成"admin"等特殊 ID 的安全风险
- 🌐 无需服务器预生成 ID 或额外网络请求，支持客户端直接生成可验证的 ID
- 🔧 提供简单 API：createId() 生成 ID，verifyId() 验证 ID 有效性
- 🧂 支持自定义盐值（salt）和 ID 长度，盐值可公开不影响安全性
- ⚡ 采用随机数据与 SHA-1 哈希混合的机制，确保 ID 难以预测和操纵
- ⚠️ 非加密级解决方案，仍需在服务端检查碰撞和 ID 长度
- 📦 支持 TypeScript/JavaScript，MIT 开源协议，由 Vercel 的 Shu Ding 创建

### [csswizardry/Obs.js：面向所有人的上下文感知Web性能工具](https://github.com/csswizardry/Obs.js)

Obs.js 是一个基于用户设备和网络环境动态调整网页性能的 JavaScript 库，通过 Navigator 和 Battery API 获取用户连接强度、电池状态等上下文信息，并自动为 HTML 元素添加对应 CSS 类或通过 window.obs 对象暴露数据，帮助开发者实现自适应内容加载策略。

- 📡 通过浏览器 API 检测网络延迟、带宽、省电模式及电池状态
- 🎨 自动为 `<html>` 元素添加情境化 CSS 类（如 `.has-battery-critical`）
- ⚡ 提供 window.obs 全局对象访问详细设备与网络指标
- 🛠️ 支持条件加载资源（如低电量时禁用动画或切换图片分辨率）
- 🔄 可配置 observeChanges 选项监听动态变化（适用于单页应用）
- 🌐 提供三种内容交付模式（rich/cautious/lite）智能建议
- 📊 涵盖硬件能力评估（内存/CPU 分级）与连接能力判断
- ⚠️ 主要兼容 Chromium 内核浏览器，需自行处理 Safari 等浏览器降级策略

### [ryanntannn/zustand-sync：适用于 zustand 的简易“多人协作”中间件](https://github.com/ryanntannn/zustand-sync)

这是一个用于 Zustand 状态管理库的轻量级多客户端同步中间件，通过 JSON Patch 实现状态同步。

- 🌐 基于 WebSocket 传输协议实现多客户端状态同步
- 🔧 采用 JSON Patch (RFC 6902) 标准进行状态变更传输
- 📦 简单易用，通过中间件方式集成到现有 Zustand 项目中
- 🚀 支持项目级路由和多种存储后端（Redis、Postgres 等）
- ⚡ 提供完整的开发路线图，包括认证授权和离线支持功能
- 🔄 通过补丁生成和应用机制确保状态变更的高效同步
- 📊 项目活跃，获得 130 星标和 2 个分支，采用 MIT 开源协议

## 更新

### [将 Mark React Compiler 集成标记为稳定 by eps1lon · Pull Request #84220 · vercel/next.js · GitHub](https://github.com/vercel/next.js/pull/84220)

Next.js 项目将 React Compiler 集成标记为稳定状态，该功能已从实验性配置移至顶层配置，并修复了相关配置迁移和 Webpack 加载器初始化问题。

- 🚀 React Compiler 集成已标记为稳定，配置从 `experimental.reactCompiler` 移至顶层 `reactCompiler`
- ⚠️ 修复了 Webpack 配置中仍引用旧实验性配置导致功能失效的问题
- 🔧 添加了配置迁移处理，对仍使用实验性配置的用户显示警告
- 📊 性能测试显示该更改不会影响现有性能指标
- 🧪 修复了部分测试用例失败问题，包括 PPR 部分水合和基础路径导航测试
- 📦 构建产物大小略有变化，部分客户端包体积微调

### [ECharts 6 新特性 - 基础入门 - 使用手册 - Apache ECharts](https://echarts.apache.org/handbook/en/basics/release-note/v6-feature/)

Apache ECharts 6.0 正式发布，带来 12 项重大升级，围绕更专业的视觉呈现、拓展数据表达边界和释放组合自由度三大核心维度，助力开发者更灵活便捷地创建图表。

- 🌟 全新默认主题：采用现代设计语言，满足多样化业务场景需求
- 🔄 动态主题切换：支持运行时无缝切换主题，提升用户体验
- 🌙 暗黑模式支持：自动适配系统暗黑/亮色模式
- 🎯 新增弦图：可视化复杂关系网络，支持渐变边色效果
- 🐝 新增蜂群图：智能分布重叠数据点，保留数值轴精度
- 📊 新增散点抖动：解决数据点过密问题，清晰展示分布
- 📈 新增断裂轴：支持撕纸效果，直观展示大差异数据
- 💹 增强股票交易图：优化标签定位，集成多种分析图表
- 🧩 新增矩阵坐标系：自由组合图表类型和组件
- 🔧 增强自定义系列：支持 npm 发布和动态注册，提升代码复用
- 🎨 新增自定义图表：提供小提琴图、等高线图等 6 种实用图表
- 📐 坐标轴标签优化：智能布局防止溢出和重叠

### [React 19.2 – React](https://react.dev/blog/2025/10/01/react-19-2)

React 19.2 版本正式发布，这是继去年 12 月 React 19 和今年 6 月 React 19.1 后的第三次重要更新。本次更新引入了多项新功能，包括 Activity 组件、useEffectEvent Hook、cacheSignal 工具以及性能追踪工具，同时增强了 React DOM 的部分预渲染能力，并优化了服务端渲染的 Suspense 边界批处理机制。此外，还修复了多个关键 bug，提升了框架的稳定性和性能。

- 🎭 **Activity 组件**：新增可见与隐藏两种模式，可优化应用性能，预渲染非活跃部分且不影响用户界面响应
- 🎯 **useEffectEvent Hook**：解决 Effect 中事件处理函数依赖变更导致重复执行的问题，需配合 eslint-plugin-react-hooks@6.1.0 使用
- 🚦 **cacheSignal 工具**：专为 React 服务端组件设计，可监听缓存生命周期并执行清理操作
- 📊 **性能追踪增强**：Chrome DevTools 新增调度器与组件渲染轨迹监控，帮助开发者精准定位性能瓶颈
- 🌐 **部分预渲染功能**：支持将静态内容预渲染至 CDN，后续再动态填充数据，提升加载效率
- 🔄 **Suspense 边界批处理**：服务端渲染时延迟显示 Suspense 内容，避免频繁切换并支持 ViewTransition 动画
- ⚡ **Node.js Web Streams 支持**：新增 renderToReadableStream 等 API，但仍推荐使用原生 Node Streams 以获得更佳性能
- 🔧 **ESLint 规则升级**：默认启用扁平配置，新增 React 编译器规则，旧配置需切换至 recommended-legacy
- 🆔 **useId 前缀更新**：默认前缀改为*r*，确保与 View Transitions 及 XML 1.0 规范的兼容性
- 🐛 **多项问题修复**：涵盖表单提交崩溃、无限循环、水合边界异常等关键稳定性改进

### [tldraw SDK 4.0 发布 - 使用 tldraw SDK 在 React 中构建白板](https://tldraw.dev/blog/tldraw-sdk-4-0)

tldraw SDK 4.0 正式发布，包含新的入门套件、无障碍功能改进及许可证变更，旨在提升开发者体验并推动项目可持续发展。

- 🛠️ 新增 CLI 工具和入门套件，可通过 `npm create tldraw` 快速创建项目，涵盖聊天机器人、工作流和多人协作等模板
- 📜 许可证变更，要求生产环境需获取试用、商业或爱好者许可证，开发环境仍可免费使用
- ♿ 实现 WCAG 2.2 AA 无障碍标准，提升画布体验的包容性
- 🎁 提供 100 天免费试用许可证，2025 年底前签约商业版可享时长抵扣优惠
- 🚀 项目增长显著，GitHub 星标超 4 万，周安装量逾 7 万，并完成 1000 万美元 A 轮融资

### [Node.js](https://nodejs.org/en/blog/release/v24.9.0)

Node.js v24.9.0 版本发布，主要包含 HTTP 升级控制、SQLite 功能增强、Worker 堆分析 API 等新特性，同时进行了多项性能优化和错误修复。

- 🚀 HTTP 模块新增 shouldUpgradeCallback，允许服务器控制 HTTP 升级流程
- 🗃️ SQLite 支持标记模板并优化了 ERM 支持，导出 Session 类
- 📊 Worker 线程新增堆分析 API，便于内存性能分析
- 🔧 加密模块改进 X509Certificate 的 signatureAlgorithm 暴露和 Promise 处理
- 🌐 网络模块优化了 IPv6 代理处理和 HTTP token 检查性能
- 📦 构建系统更新了 OpenHarmony 支持并优化了 ESLint 规则打包
- 🛠️ 核心代码重构了字符串处理和 Eternal 设置逻辑，提升运行效率
- 📚 文档更新了安全升级策略和 V8 快速 API 使用指南
- 🐛 修复了 REPL 大字符串粘贴性能、SQLite 会话崩溃等多个问题
- 🔄 依赖项升级至 OpenSSL 3.5.3 和 Undici 7.16.0

## 设计

### [设计系统：前端和谐的真正源泉——设计系统如何拯救你——矿工篇](https://blog.codeminer42.com/design-systems-the-true-source-of-frontend-peace/)

设计系统是前端开发中确保用户体验一致性的重要工具，它通过可复用组件和规范指南提升开发效率与产品质量。

- 🎨 设计系统包含可复用的 UI 组件库、风格指南、使用规范和文档，确保视觉与交互一致性
- ⚡ 能加速开发流程，简化新成员入职培训，并支持项目规模扩展
- 🚫 避免界面不一致性问题，如按钮样式冲突导致用户误操作
- ♿ 提升可访问性，确保辅助技术用户能顺畅使用产品
- 📚 完整文档体系让开发者减少猜测时间，专注功能构建
- 🌱 建议项目初期投入设计系统，为产品可持续发展奠定基础

### [在用户付出的经济中，做一笔划算的交易，而非欺诈 • 莉亚·维鲁](https://lea.verou.me/blog/2025/user-effort/)

本文探讨了艾伦·凯的设计原则“简单的事情应该简单，复杂的事情应该可能”的深层应用，强调用户体验设计中需平衡用户努力与任务复杂度，通过优化复杂度 - 努力曲线来创造愉悦的产品体验。

- 🎯 核心原则：简单任务应轻松完成，复杂任务需保持可实现性，关键在于设计平滑的复杂度 - 努力过渡曲线
- 💡 用户努力即货币：将用户操作视为支付成本，需确保投入与获得价值成比例，避免用户产生“被宰割”感
- ⚠️ 警惕可用性悬崖：防止任务复杂度微增导致用户努力急剧攀升的设计陷阱（如 HTML 视频控件自定义）
- 📶 最大化信噪比：减少重复输入和冗余操作，确保每个用户动作都能有效传递意图（如智能推导信用卡类型）
- 🔍 摩擦隐于无形：用户更易抱怨功能缺失而非操作困难，需通过可用性测试和内部体验主动发现摩擦点
- 👑 用户需求优先：在实现复杂度和用户体验的权衡中，应坚持将用户心智模型置于技术实现之上
- 👥 消费者优于生产者：在多层次系统中（如 Web 生态），优先满足终端用户需求，让专业开发者承担适当复杂度
- ✨ 微交互创造惊喜：通过自动填充、智能默认值等细节设计，累积微小愉悦感形成整体卓越体验

## AI

## 其他

### [工程领导失败模式 - Lior Neu-ner 著](https://newsletter.posthog.com/p/tech-lead-failure-modes?r=5t1b8o)

团队领导者常见的五种失败模式及规避方法，旨在帮助技术管理者提升团队效能与自主性。

- 🚧 成为决策瓶颈：过度参与代码评审和任务规划会导致交付停滞。解决方案包括推动透明协作、下放决策权、建立跨团队直连通道，并通过目标管理替代任务管理
- 💻 脱离技术实践：沉溺会议管理会导致编程能力退化。建议保留 80-90% 编码时间，推行异步协作，取消非必要会议，用文档和录屏替代同步沟通
- 🎯 固守错误目标：因害怕失败而拒绝调整方向。应建立月度增长评审机制，结合用户数据和业务指标动态优化路线图
- ⭐ 降低人才标准：回避负面反馈导致团队水平滑坡。需定期实施“挽留测试”，通过教练辅导或人员调整维持高标准
- 🦸 充当救火队长：包揽危机处理会削弱团队能力。可通过结对编程、过程文档化、微分享会议针对性招聘来系统化赋能团队
